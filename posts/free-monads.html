<!DOCTYPE html lang="en">
    <head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<meta http-equiv="X-UA-Compatible" content="chrome=1" />
	<title>Marcin Szamotulski Homepage</title>
	<meta name="description" content="I am a mathematician (PhD) and a software engineer delivering solutions using JavaScript, Haskell, Purescript and Python." />
	<meta name="author" content="Marcin Szamotulski" />
	<meta name="keywords" content="JavaScript React Angular Python Haskell PureScript programming  web applications PWA" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta name="twitter:site" content="@me_coot" />
	<meta name="twitter:title" content="Marcin Szamotulski - software engineer" />
	<meta name="twitter:description" content="I am a full-stack web developer, and a mathematician" />
	<meta name="twitter:creator" content="@coot_" />
	<meta name="twitter:image:src" content="http://marcinszamotulski.me/images/marcinszamotulski-large.jpg" />
	<meta name="twitter:domain" content="marcinszamotulski.me" />
	<meta prefix="og: http://ogp.me/ns#" property="og:title" content="Marcin Szamotulski - software engineer" />
	<meta prefix="og: http://ogp.me/ns#" property="og:site_name" content="Marcin Szamotulski - software engineer" />
	<meta prefix="og: http://ogp.me/ns#" property="og:description" content="I am a full-stack web developer and a mathematician living in Lisbon, Portugal" />
	<meta prefix="og: http://ogp.me/ns#" property="og:type" content="website" />
	<meta prefix="og: http://ogp.me/ns#" property="og:url" content="http:/marcinszamotulski.me" />
	<meta prefix="og: http://ogp.me/ns#" property="og:image" content="http://marcinszamotulski.me/images/marcinszamotulski-large.jpg" />
	<meta property="fb:admins" content="100001888925907" />

	<link rel="manifest"   href="/manifest.json" />
	<link rel="import"     href="/header.html" data-target=".info-hdr" />
	<link rel="stylesheet" href="/assets/style.css" />
	<link rel="stylesheet" href="/assets/normalize.css" />
	<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" />
	<link rel="stylesheet" href="/assets/print_style.css" media="print"/>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600" />

	<script type="text/javascript" async src="/bower_components/html5shiv/dist/html5shiv.min.js"></script>
	<script type="text/javascript" async src="/bower_components/html5shiv/dist/html5shiv-printshiv.min.js"></script>
	<script type="text/x-mathjax-config">
	    MathJax.Hub.Config({
                tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
                TeX: {
                    extensions: ["AMSmath.js"]
                },
            });
	</script>
	<script type="text/javascript" async
	    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
	<script type="text/javascript" src="/assets/index.js"></script>
	</script>
    </head>
    <body>
	<div id="wrapper" class="wrapper post">
	    <header class='info-hdr'></header>
	    <main>
		<header>
		    <h1 class="section_h" id="freeness-from-free-algebras-to-free-monads">From free algebras to free monads</h1>
		</header>
		<p>
		    In <a href="https://en.wikipedia.org/wiki/Universal_algebra">Universal algebra</a>
		    <strong>freeness</strong> is a well defined algebraic
		    property. We will explore equational theories which are
		    tightly connected to free algebras.  We will consider free
		    monoids.  Then we'll explain how monads can be brought into
		    the picture in the context of monoidal categories. This
		    will lead to a precise definition of free monad as free
		    monoids.  Let’s start with a general definition.
                </p>


		<h2>Preliminaries</h2>
		<p>
		    We will need some preliminary definitions.  Let's begin
		    with a definition of algebra. For a set $A$ we will denote
		    $A^n$ the $n$-th cartesian product of $A$, i.e.
		    $A^2=A\times A$.

		    <p>
			An <b>algebra</b> $\underline{A}$ is a set $A$ together
			with a finite set of operations $f_i:A^{j_i}\rightarrow A$
			($i=1,\ldots,n$), usually simply written as
			$\underline{A}=(A, (f_i)_{i=1,\ldots,n})$. For
			operation $f_i$ the natural number $j_i$ is called the
			arity of the operation, which is a finite natural
			number.  The set $A$ is usally called <b>universum</b>
			of the algebra $\underline{A}$.  The set of arities
			operations is called <b>type of the algebra</b> $A$.  
		    </p>

		    Examples includes many classical algebraic structures, like
		    <i>semigroups</i>, where there is only a single operation of
		    artiy 2, <i>monoids</i> which in addition have one operation of
		    arity $0$ - the unit element of multiplication.  Other
		    source of examples are <i>Boolean algebras</i> with two 2-ary
		    operations $\wedge$ and $\vee$ or more generally
		    <i>lattices</i>,  <i>Heyting algebras</i>.  Also <i>rings</i>, <i>fields</i>,
		    and many many other structures.  Universal algebra has
		    a very general theory describing common conncepts but also
		    deals with very special cases of some of more esotheric
		    algebras.

		    <p id="homomorphism">
			A <b>homomorphism</b> between two algebras $(A,
			(f_i^A)_{i=1,\ldots,n})$ and $(B, (f_i^B)_{i=1,\ldots,n})$
			(of the same type) is a map $h:A\rightarrow B$ with the
			property that for every $i$:
			$$
			    h(f^A_i(a_1,\ldots, a_{i_j})) = f^B_i(f(a_1),\ldots,f(a_{i_j}))
			$$
		    </p>

		    This means that <i>homomorphism preserve operations</i>.  For
		    example a homomorphism of monoids is a map that preserves
		    the multiplication and unit.  For boolean algebras, it
		    means that a homorphism preserves the  $\vee$ (also called
		    <i>join</i>) and $\wedge$ (usally called <i>meet</i>)
		    operations, etc. 

		    <p>
			It is an easy observations that homorphism are closed under
			composition and since the identity map is always
			a homomorphism this leads to well defined categories, e.g.
			category of monoids, category of boolean algebras, category
			of rings ...
		    </p>
		</p>

                <h2>Equational theories and free algrebras </h2>
		<p>
		    An algebra $A$ is <b>free</b> in for the class of
		    algebras $\mathcal{C}$ over a subset $S\subset A$ if
		    for every $B\in\mathcal{C}$ every map $S\rightarrow B$
		    uniquelly extends to a <a href="#homomorphism">homomorphism</a>
		    $A\rightarrow B$.
		</p>
		<p>
		    Many theories allow for free albebras.  Let's give some
		    simple examples.  The monoid of natural numbers
		    $\mathbb{N}$ with addition and $0$ as its unit element is
		    a free monoid generated by the set ${1}$.  It is both free
		    in the class of all monoids and in the class of commutative
		    monoids.  The cartsian product $\mathbb{N}^n$ is a free
		    commutative monoid generated over the set
		    $\{(1,0,\ldots,0),(0,1,0,\ldots,0),\ldots,(0,\ldots,0,1)\}$,
		    but it's not a free monoid in the class of all monoids.
		    A <a href="https://en.wikipedia.org/wiki/Free_group">free group</a>
			 with two genrators can be pictures by the
		    <a href="https://en.wikipedia.org/wiki/Cayle">Cayley graph</a>
		    (which is a fractal).
		</p>
		<p>
		    As you can see the definition of a free algebra requires
		    a context, this interesting in its own!. So there are free
		    monoids in the class of all monoids and there are  ree
		    commutive monoids in the class of commutative monoids (i.e.
		    monoids in which $m\cdot n=n\cdot m$ for each elements
		    $m,n$).
		</p>
		<p>
		    <i>Free algebras</i> play an essiential role in a proof of
		    a beutiful result
		    <a href="http://mathworld.wolfram.com/BirkhoffsTheorem.htmp">Birkhoff theorem</a>.
		    It states that a class of algebras $\mathcal{C}$ is an
		    <b>equational theory</b> if and only if the class is closed under
		    cartesian products,
		    <a href="#homomorphism">homomorphic</a>
		    images and subalgebras.  <i>Equational theories</i> are classes of
		    algebras which staisfy a set of equations; examples
		    includes: <i>semigroups</i>, <i>monoids</i>, <i>groups</i> or <i>boolean</i> or <i>Heyting
			algebras</i> but also <i>commutative (abelian) semigroups</i>
		    / <i>monoids</i> / <i>groups</i>, and many other classical algebraic
		    structures.
		</p>
		<p>
		    We need to be a little bit more precise language to speak
		    about <i>equational theories</i> for various algebras.
                </p>

                <h3>Terms, term functions and their algebra</h3>
		<p id="term">
		    Let’s consider an algebra $\underline{A}=(A, (f_i)_{i=1,\ldots,n})$.
		    Then the set of <strong>terms</strong> on a set $X$
		    (set of variables) is inductivelly definied as:
                    <ul>
                        <li id="term-1">
                            each $x\in X$ is a term (of arity $1$)
                        </li>
                        <li id="term-2">
                            each $f_i(x_1,\dots ,x_{j_i})$ is a term of arity $j_i$ for $x_1,\dots ,x_{j_i}\in X$
                        </li>
			<li id="term-3">
                            if $g_1,\dots  g_n$ are terms of arities $j_1$ to $j_n$
                            respectivelly, and $g$ is a term of arity $n$ then
                            $g(g_1(x_{11},\dots,x_{1j_1}),\dots, g_n(x_{n1},\dots,x_{nj_n}))$ is a term of arity
                            $j_1+\dots+j_n$ with $x_{kl}\in X$.
                        </li>
                    </ul>
                </p>
		<p>
		    For example in groups both $x^{-1}\cdot x$ and
		    $x\cdot y$ and $1$ (the unit of the group)
		    are terms. So terms are just abstract expressions that one
		    can build using some set of algebraic operations that are
		    supported by the algebra type. Each term $t$
		    defines a term function on every algebra of a given type.
		    In groups the following terms are distinct but they define
		    the equal term function: $x^{-1}\cdot x$ and
		    $1$; $(x\cdot y)\cdot z$ and
		    $x\cdot (y\cdot z)$; But the two terms $x\cdot y$
		    and $y\cdot x$ define non equal term functions (on
		    non-abelian groups). Another example comes from boolean
		    algebras (or more broadly lattice theory) where the two
		    terms $x\wedge (y\vee z)$ and $(x\wedge y)\vee(x\wedge z)$
		    define equal term functions on Boolean algebras (or more
		    generally
		    <a href="https://en.wikipedia.org/wiki/Distributive_lattice">distributive lattices</a>).
		    If $t$ is a term then the associated term
		    function on an algebra $\underline{A}$ we let denote by
		    $\tilde{t}$. Term functions are natural to express
		    equalities within a theory. Now we are ready to formally
		    define eqauational classes of algebras.
                </p>

		<p>
		    A class of algebras $\mathcal{C}$ is an <strong>equational
			theory</strong> if and only if there exists a set of
		    pairs of terms $\mathbf{E}$ such that the class consists
		    exactly of algebras $A$ for which the following
		    condition is satisified: for each pair of terms $(t, s)\in
		    \mathbf{E}$ two corresponding term functions $\tilde{t}$ and
		    $\tilde{s}$ are equal on every algebra $\mathcal{A}$ in the
		    class $\mathcal{C}$.
                </p>

		<p>
		    For example the class of monoids is an equational theory
		    for $\mathbf{E}=\{(1\cdot x, x), (x\cdot 1, x), ((x\cdot y)\cdot z, x\cdot (y\cdot z))\}$
		    i.e. all the algebras with two operations: one of arity
		    0 (the unit) and one of arity 2 (the multiplication), such
		    that the $1$ is the unit for multiplication
		    $\cdot $ and multiplication is associative. The class
		    of commutative monoids is also an equational theory with
		    one additional equation $(x\cdot y, y\cdot x)$. Groups,
		    Boolean or Heyting algebras, lattices are also an
		    equational theories.
                </p>

		<p>
		    Coming back to free algebras: it turns out that the set of
		    <em>terms</em> $\mathsf{T}(X)$ on a given set of
		    variables $X$ has an algebra structure: just give by the
		    inductive step in the defintiion of <a href="#term-3">terms</a>:
		    if $t_i\in \mathsf{T}(X)$ then $f_j(t_1,\ldots,t_{j_i})\in \mathsf{T}(X)$.
		    
		    Furthermore $\mathsf{T}$ is a free algebra in the class of
		    all algebras of the given type.  An extension of a map
		    $f:X\rightarrow\underline{A}=(A,(f_i^A)_{i=1,\ldots,n})$
		    can be build inductively following the definition of
		    <a href="#term">terms</a> and using the
		    <a href="#homomorphism">homomorphism property</a>:
		    $$
			f(f_i(t_1,\ldots,f_{i_j})) := f_i^A(f(t_1),\ldots,f(t_{i_j}))
		    $$

		    Note that the class of algebras of the same type is usually
		    very broad, but this is the first approximation to build
		    free algebras in an equational theory. This is just the
		    equational theory for the empty set $\mathbf{E}$.  Let’s see
		    this on an example and let us consider algebras of the same
		    type as a monoid: with one nullary operation (unit or
		    <code>mempty</code> if you like) and one 2-ary operation
		    (multiplication / <code>mappend</code>).  Let $X$ be a set of
		    variables. Then $1$ is a valid term, and also if $t_1$ and
		    $t_2$ are terms on $X$ then also $t_1\cdot t_2$ is a term.
		    If you have a map $f:X\rightarrow M$ to a monoid $M$, you
		    don’t have a choice while extending it to a (monoid)
		    homomorphism $\mathsf{T}(X)\rightarrow M$: $t_1\cdot t_2$
		    must be mapped to $f(t_1)\cdot f(t_2)\in M$.
		</p>
		<p id="congruence">
		    Moreover the set of equations that defines the class of
		    monoids defines a
		    <a href="https://en.wikipedia.org/wiki/Congruence_relation">congruence relation</a>
		    on the term algebra $\mathsf{T}(X)$ (i.e. an
		    <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>
		    which is compatible with operations: $x_1\sim y_1$ and
		    $x_2\sim y_2$ then $(x_1\cdot y_1) \sim (x_2\cdot
		    y_2)$). 
		</p>
		<p>
		    Congruences are exactly the relations which allow to build
		    algebra structure on the quotient $\underline{A}/\sim$ (the
		    set of equivalence classes), so that the quotient map is an
		    algebra homomorphism.  The key point here is that if we
		    take the term algebra and take a quotient by the smallest
		    congruence that contains all the pairs of terms which
		    belong to the set $\mathbf{E}$ we will obtain a free
		    algebra in the equational class defined by $\mathbf{E}$.
                </p>
                <h3>Free monoids</h3>
		<p>
		    Let’s take a look on a free monoid that we can build this
		    way. First let us consider the free algebra
		    $\mathsf{T}(X)$ for algebras of the same type as monoids
		    (which include non associative monoids, which unit does not
		    behave like a unit). And let $\sim$ be the smallest
		    relation (congruence) that enforces $\mathsf{T}(X)/\sim$ to
		    be a monoid.
                </p>

		<p>
		    Since monoids are associative every element in
		    $\mathsf{T}(X)/\sim$ can be represented as $((x_1\cdot
			x_2)\cdot \ldots) \cdot x_n$ (where we group
		    brackets to the left). Multiplication of $((x_1\cdot
			x_2)\cdot \ldots) \cdot x_n$ and $((y_1\cdot
			y_2)\cdot \ldots) \cdot y_n$ is just
		    $(((x_1\cdot x_2)\cdot \ldots \cdot x_n)\cdot
			y_1)\cdot y_2)\cdot \ldots )\cdot y_n$ In Haskell
		    if you’d represent the set $X$ as a type
		    $a$ then the free monoid is just represented by
		    a list type $[a]$ with multiplication: list
		    concatenation. Just think of
<pre class="haskell"><code>-- A set with `n` elements corresponds
-- to a type with `n` constructors:
data X = X_1|⋯|X_n</code></pre>

		<h2 id="monads">Free Monads</h2>
		<p>
		    It turns out monads in $Hask$ are also an
		    equational theory. Just the terms are higher kinded:
		    $*\rightarrow*$ rather than $*$ as in
		    monoids. In a free monoid case we took all terms to
		    construct a monoid from a given type.  The same
		    construction works in the land of monads, but we need to
		    look at them from another perspective.  Let us first take
		    a mathematical definition of view on monads.
		</p>
		<p id="monad">
		    A <b>monad</b> is an (endo) <i>functor</i> <code>m</code>
		    with two <i>natural transformations</i>:
<pre class="haskell"><code>class Monad where
    return :: a -&gt; m a
    join   :: m(m a) -&gt; m a</code></pre>
		    which is unital and associative, i.e. the following law holds:
<pre class="haskell"><code>join . join == join . fmap join          -- associativity
join . return  = id = join . fmap return -- unitality</code></pre>
		</p>
		<p>These axioms are easier to understand as diagrams:
$$
\begin{equation}\label{monad-associativity}
\begin{array}{ccc}
    m\;(m\;(m\;a)                & \xrightarrow{join} & m\;(m\;a) \\\\
    \small{fmap\;join}\downarrow &                    & \downarrow \small{join} \\\\
    m\;(m\;a)                    & \xrightarrow{join} & m\;a \\\\
\end{array}
\end{equation}
$$
                <p>and
$$
\begin{equation}\label{monad-unitality}
\begin{array}{ccccc}
m\;a & \xrightarrow{return} & m\;(m\;a)              & \xleftarrow{fmap\;return} & m\;a \\\\
     & \small{id}\searrow   & \downarrow\small{join} & \swarrow\small{id}        & \\\\
     &                      & m\;a                   &                           &
\end{array}
\end{equation}
$$
		<p>
		    It is a basic lemma that this definition a monad is
		    equivalent to what Haskellers are used to:
<pre class="haskell"><code>class Monad where
    return :: a -&gt; m a
    &gt;&gt;=    :: m a -&gt; (a -&gt; m b) -&gt; m b</code></pre>
		<p>Having <code>join</code> one defines <code>&gt;&gt;=</code> as
<pre class="haskell"><code>ma &gt;&gt;= f = join $ f &lt;$&gt; ma</code></pre>
		<p>and the other way, having <code>&gt;&gt;=</code> then
<pre class="haskell"><code>join = (&gt;&gt;= id)`</code></pre>
                    Not only these two constructions are reverse to each other,
                    but also they translate the monad laws correctly.
                </p>

                <h3>Monoids in monoidal categories</h3>

		To define a monoid $M$ in the cateogry $\mathcal{Set}$ (of
		sets) one needs the product $M\times M$.  Abstraction of this
		structure leads to monoidal categories.

		<p id="monoidal-category">
		    Category $\mathcal{C}$ with a <a
			href="https://ncatlab.org/nlab/show/bifunctor">bifunctor</a>
		    $-\otimes-:\mathcal{C}\times\mathcal{C}\rightarrow\mathcal{C}$
		    is called <b>strict monoidal category</b> if `\otimes` is
		    <i>associative</i> and <i>unital</i>, i.e. for all
		    $a,b,c\in\mathcal{C}$ $(a\otimes b)\otimes c = a\otimes
		    (b\otimes c)$ and there exists a unit object $1$ such that
		    $1\otimes a=a=a\otimes 1$.
		</p>

		<p>
		    Most examples of monoidal categories are not strict but are associative and
		    unital up to a natural transformation.  Think of
		    $(A\times B)\times C\simeq A\times(B\times C)$ in $\mathcal{Set}$ (or any
		    category with (finite) products, like $\mathcal{Hask}$).
		</p>

		<p>
		    Now we can generalise a definition of a monoid to such categories:
		</p>

                <p id="monoid-in-a-monoidal-category">
		    A <b>monoid</b> in a monoidal category $\mathcal{C}$ with monoidal
		    product $-\otimes-$ and a unit $1$ is an object $m$ with a pair of morphisms
		    $$
		    \mathrm{mappend}:\;m\otimes m\rightarrow m
		    $$
		    and:
		    $$\mathrm{mempty}:\;1\rightarrow m$$
		    such that

$$
\begin{equation}\label{monoid-associtivity-in-monoidal-category}
\begin{array}{ccc}
    m\otimes m\otimes m                                  & \xrightarrow{\mathrm{mappend}\otimes\mathrm{id}} & m\otimes m \\\\
    \small{\mathrm{id}\otimes\mathrm{mappend}}\downarrow &                                                  & \downarrow \small{\mathrm{mappend}} \\\\
    m\otimes m                                           & \xrightarrow{\mathrm{mappend}}                   & m \\\\
\end{array}
\end{equation}
$$
                <p>and
$$
\begin{equation}\label{monoid-unitality-in-monoidal-category}
\begin{array}{ccccc}
m = m \otimes 1 & \xrightarrow{\mathrm{id}\otimes\mathrm{mempty}} & m\otimes m                         & \xleftarrow{\mathrm{mappend}\otimes\mathrm{id}} & 1\otimes m = m \\\\
                & \small{\mathrm{id}}\searrow                     & \downarrow\small{\mathrm{mappend}} & \swarrow\small{\mathrm{id}}                     & \\\\
                &                                                 & m                                  &                                                 &
\end{array}
\end{equation}
$$

                </p>

                <p>
                    The main point of this section is that these diagrams have
                    exatly the same shape as associativity and unitality for
		    <a href="#monad">monads</a>. Indeed, a monoid in the category of endofunctor
                    with a monoidal product $\otimes$ to be functor composition
                    and unit the identity functor is a monad.  In category
                    theory this category is strict monoidal,  if you try to
                    type this in Haskell you will end up with a non strict
                    <a href="https://ncatlab.org/nlab/show/monoidal+category">monoidal structure</a>,
                    where you will need to show
                    <a href="https://ncatlab.org/nlab/show/pentagon+identity">penthagon equation</a>.
                </p>

                <p>
                    These consideration suggest that we should be able to build
                    a free monad using our algebraic approach to free algebras. And
		    this is what we will follow in the next
		    <a href="free-monad">section</a>.
                </p>

		<h3 id="free-monad">Free monads in $\mathcal{Hask}$</h3>
		<p>
		    Firstly, what should replace the set of generators $X$ in
		    $\mathsf{T}(X)/\sim$?
		    First we generalised from the category of sets $\mathcal{Set}$ to
		    a monoidal category $(\mathcal{C},\otimes, 1)$: its clear
		    that we just should pick an object of the category
		    $\mathcal{C}$.  Now since our category is the category of
		    (endo) functors of $\mathcal{Hask}$ the set of generators
		    is just a functor.  So let's pick a functor <code>f</code>.
		</p>
		<p>
                    Now to construct a free monad for a functor
		    <code>f</code>?  The description of a free algebra sais we
		    should pick the $\mathsf{T}(f)/\sim$.  Note that here
		    $\mathsf{T}(f)$ and $\mathsf{T}(f)/\sim$ are functors!  And let call $\mathsf{Free}(f)=\mathsf{T}(f)/\sim$.  So
		    how the terms looks like in this setting?  We need to take
		    all the expressions of Haskell's type (for arbitrary long
		    products):
		    $$
			\begin{equation}
			    \begin{array}{c}
				\bigl(\mathsf{Free}(f)\otimes\mathsf{Free}(f)\otimes\ldots\otimes \mathsf{Free}(f)\bigr)(a) \\\\
				\quad\quad = \mathsf{Free}(f)\bigl(\mathsf{Free}(f)\bigl(\ldots (\mathsf{Free}(f)(a)\bigr)\ldots\bigr)
			    \end{array}
			\end{equation}
		    $$
                    In our setup the monoidal product $-\otimes-$ is just the
                    functor composition, thus
		    $\mathsf{Free}(f)(a)$ must be a type which (Haskell's)
		    terms are of Haskell's types:
		    <pre class="haskell"><code>a, f a, f (f a), f (f (f a)), ...</code></pre>
                </p>
		<p>
		    The monadic <code>join</code> should take something of
		    type $\mathsf{Free}(f)\;(\mathsf{Free}(f)\;(a))$, e.g. $f^n(b)=f\;(f\;(\dots f\;(b)\dots)$ (by abusing the notation $f^n$)
                    where $b$ has type
		    $f^m(a)=(f\;(f\;(\dots(f\;(a)\dots)$ into $\mathsf{Free}(f)(a)$ and
		    it should be quite clear how to do that: just take
                    the obvoius element of type $f^{n+m}(a)$ - we'll make it
                    concrete in a second...  Altogether, this is a good trace
                    of a monad, so let us translate this into a concrete
                    Haskell type:
<pre class="haskell"><code>data Free f a
    = Return a
      -- ^ the terms of type a
    | Free (f (Free f a))
      -- ^
      -- recursive definition which embraces
      -- `f a`, `f (f a)` and so on</code></pre>
		</p>
		<p>
		    <code>Free</code> is just a tree shaped by the functor
                    <code>f</code>.  This type indeed embraces all the terms of
                    types: <code>a, f a, f (f a), ...</code> into a single
                    type.  Now the monad instance:
<pre class="haskell"><code>instance Monad (Free f a) where
    return = Return
    join (Return ma) = ma
    -- ^ stich a tree of trees into a tree
    join (Free fma) = Free $ join &lt;$&gt; fma
    -- ^ recurse to the leaves</code></pre>
                    As you can see, takes a tree of trees and outputs a a bigger tree, that's what <code>join</code> does on the <code>Return</code> constructor.
                </p>
                <p>
                    <code>join</code> corresponds to <code>foldMap</code> which is
                    defined in a very similar way
<pre class="haskell"><code>foldMap :: Monoid m => [m] -> m
foldMap _ [] = mempty
foldMap f (a : as) = mappend (f a) (foldMap f as)</code></pre>
                    If we had polymorphic function over monoidal categories,
                    <code>foldMap</code> and <code>join</code> would be
                    specialisations of the same function!
                </p>

            <h2>Final remarks</h2>
            <p>
                I hope I convienced you that monads are algebraic constructs and I hope
                you'll find univeral algebra approach useful. In many cases we
                are dealing with algebraic structures which we require to
                satisfy certiain equations. Very often they fit into equational
                theories, which have a very clear description and which allow
                free objects. Freeness is the property that lets one easily
                interpret the free object in any other object of the same type.
                In the monad setting they are really useful when writting DSLs,
                since you will be able to interpret it in any monad, like IO or
                some pure monad.
            </p>
	    </main>
    </body>
</html>
