{"version":3,"file":"workbox-routing.prod.v2.0.0.js","sources":["../../../../lib/error-factory.js","../../src/lib/error-factory.js","../../../../lib/error-stack-parser-no-op.js","../../../../lib/assert.js","../../src/lib/normalize-handler.js","../../src/lib/constants.js","../../src/lib/route.js","../../../../node_modules/path-to-regexp/node_modules/isarray/index.js","../../../../node_modules/path-to-regexp/index.js","../../src/lib/express-route.js","../../../../lib/log-group.js","../../../../lib/environment.js","../../../../lib/log-helper.js","../../src/lib/navigation-route.js","../../src/lib/regexp-route.js","../../src/lib/router.js"],"sourcesContent":["/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n'use strict';\n\n/**\n * A simple class to make errors and to help with testing.\n */\nclass ErrorFactory {\n  /**\n   * @param {Object} errors A object containing key value pairs where the key\n   * is the error name / ID and the value is the error message.\n   */\n  constructor(errors) {\n    this._errors = errors;\n  }\n  /**\n   * @param {string} name The error name to be generated.\n   * @param {Error} [thrownError] The thrown error that resulted in this\n   * message.\n   * @return {Error} The generated error.\n   */\n  createError(name, thrownError) {\n    if (!(name in this._errors)) {\n      throw new Error(`Unable to generate error '${name}'.`);\n    }\n\n    let message = this._errors[name].replace(/\\s+/g, ' ');\n    let stack = null;\n    if (thrownError) {\n      message += ` [${thrownError.message}]`;\n      stack = thrownError.stack;\n    }\n\n    const generatedError = new Error();\n    generatedError.name = name;\n    generatedError.message = message;\n    generatedError.stack = stack;\n    return generatedError;\n  }\n}\n\nexport default ErrorFactory;\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport ErrorFactory from '../../../../lib/error-factory';\n\nconst errors = {\n  'express-route-invalid-path': `When using ExpressRoute, you must\n    provide a path that starts with a '/' character (to match same-origin\n    requests) or that starts with 'http' (to match cross-origin requests)`,\n};\n\nexport default new ErrorFactory(errors);\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/**\n * A no-op export matching the ErrorStackParser interface, to be included in\n * production, minified builds.\n */\nexport default {\n  parse: () => [],\n};\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/* eslint-disable require-jsdoc */\n\nimport ErrorStackParser from 'error-stack-parser';\n\nexport function atLeastOne(object) {\n  const parameters = Object.keys(object);\n  if (!parameters.some((parameter) => object[parameter] !== undefined)) {\n    throwError('Please set at least one of the following parameters: ' +\n      parameters.map((p) => `'${p}'`).join(', '));\n  }\n}\n\nexport function hasMethod(object, expectedMethod) {\n  const parameter = Object.keys(object).pop();\n  const type = typeof object[parameter][expectedMethod];\n  if (type !== 'function') {\n    throwError(`The '${parameter}' parameter must be an object that exposes a\n      '${expectedMethod}' method.`);\n  }\n}\n\nexport function isInstance(object, expectedClass) {\n  const parameter = Object.keys(object).pop();\n  if (!(object[parameter] instanceof expectedClass)) {\n    throwError(`The '${parameter}' parameter must be an instance of\n      '${expectedClass.name}'`);\n  }\n}\n\nexport function isOneOf(object, values) {\n  const parameter = Object.keys(object).pop();\n  if (!values.includes(object[parameter])) {\n    throwError(`The '${parameter}' parameter must be set to one of the\n      following: ${values}`);\n  }\n}\n\nexport function isType(object, expectedType) {\n  const parameter = Object.keys(object).pop();\n  const actualType = typeof object[parameter];\n  if (actualType !== expectedType) {\n    throwError(`The '${parameter}' parameter has the wrong type. (Expected:\n      ${expectedType}, actual: ${actualType})`);\n  }\n}\n\nexport function isArrayOfType(object, expectedType) {\n  const parameter = Object.keys(object).pop();\n  const message = `The '${parameter}' parameter should be an array containing\n    one or more '${expectedType}' elements.`;\n\n  if (!Array.isArray(object[parameter])) {\n    throwError(message);\n  }\n\n  for (let item of object[parameter]) {\n    if (typeof item !== expectedType) {\n      throwError(message);\n    }\n  }\n}\n\nexport function isArrayOfClass(object, expectedClass) {\n  const parameter = Object.keys(object).pop();\n  const message = `The '${parameter}' parameter should be an array containing\n    one or more '${expectedClass.name}' instances.`;\n\n  if (!Array.isArray(object[parameter])) {\n    throwError(message);\n  }\n\n  for (let item of object[parameter]) {\n    if (!(item instanceof expectedClass)) {\n      throwError(message);\n    }\n  }\n}\n\nexport function isValue(object, expectedValue) {\n  const parameter = Object.keys(object).pop();\n  const actualValue = object[parameter];\n  if (actualValue !== expectedValue) {\n    throwError(`The '${parameter}' parameter has the wrong value. (Expected:\n      ${expectedValue}, actual: ${actualValue})`);\n  }\n}\n\nfunction throwError(message) {\n  // Collapse any newlines or whitespace into a single space.\n  message = message.replace(/\\s+/g, ' ');\n\n  const error = new Error(message);\n  error.name = 'assertion-failed';\n\n  const stackFrames = ErrorStackParser.parse(error);\n\n  // If, for some reason, we don't have all the stack information we need,\n  // we'll just end up throwing a basic Error.\n  if (stackFrames.length >= 3) {\n    // Assuming we have the stack frames, set the message to include info\n    // about what the underlying method was, and set the name to reflect\n    // the assertion type that failed.\n    error.message = `Invalid call to ${stackFrames[2].functionName}() â€” ` +\n      message;\n  }\n\n  throw error;\n}\n","import {hasMethod, isType} from '../../../../lib/assert';\n\n/**\n * @param {function|module:workbox-runtime-caching.Handler} handler The\n * handler to normalize.\n * @return {Object} An object with a `handle` property representing the handler\n * function.\n */\nexport default function normalizeHandler(handler) {\n  if (typeof handler === 'object') {\n    hasMethod({handler}, 'handle');\n    return handler;\n  } else {\n    isType({handler}, 'function');\n    return {handle: handler};\n  }\n}\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @private\n * @type {string}\n * @memberof module:workbox-routing\n */\nexport const defaultMethod = 'GET';\n\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @private\n * @type {Array.<string>}\n * @memberof module:workbox-routing\n */\nexport const validMethods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n];\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport {isType, isOneOf} from '../../../../lib/assert';\nimport normalizeHandler from './normalize-handler';\nimport {defaultMethod, validMethods} from './constants';\n\n/**\n * This is the definition of the `match` callback passed into the\n * `Route` constructor.\n *\n * This callback is used to determine if a new `fetch` event can be served\n * by this `Route`. Returning a truthy value indicates that this `Route` can\n * handle this `fetch` event. Return `null` if this shouldn't match against\n * the `fetch` event.\n *\n * If you do return a truthy value, the object will be passed to the\n * Route's `handler` (see the\n * [Route Constructor]{@link module:workbox-routing.Route}).\n *\n * @callback Route~matchCallback\n * @param {Object} input\n * @param {URL} input.url The request's URL.\n * @param {FetchEvent} input.event The event that triggered the `fetch` handler.\n * @return {Object|null} To signify a match, return a truthy value, otherwise\n * return null if the route shouldn't match. If you return an Object with\n * contents it will be passed to the `handler` in the `Route` constructor.\n * @memberof module:workbox-routing\n */\n\n/**\n * This is the definition of the `handler` callback that can be passed into the\n * `Route` constructor.\n *\n * The `handler` callback is called when a request has been matched by\n * a `Route` and should return a Promise that resolves with a `Response`.\n *\n * @callback Route~handlerCallback\n * @param {Object} input\n * @param {URL} input.url The request's URL.\n * @param {FetchEvent} input.event The event that triggered the `fetch` handler.\n * @param {Object} [input.params] Parameters returned\n * the Route's [match callback]{@link\n *   module:workbox-routing.Route~matchCallback} function. This will be\n * undefined if nothing was returned.\n * @return {Promise<Response>} The response that will fulfill the request.\n * @memberof module:workbox-routing\n */\n\n/**\n * A `Route` allows you to tell a service worker that it should handle\n * certain network requests using a specific response strategy.\n *\n * A consists or a matcher and a handler. A matcher needs to determine if a\n * route should be used for a request. A handler should handle the request\n * if it does match a Router.\n *\n * Instead of implementing your own handlers, you can use one of the\n * pre-defined runtime caching strategies from the\n * {@link module:workbox-runtime-caching|workbox-runtime-caching} module.\n *\n * There are also pre-defined Route's provided by this library:\n * {@link module:workbox-routing.RegExpRoute|RegExpRoute}\n * and {@link module:workbox-routing.ExpressRoute|ExpressRoute} subclasses\n * which provide a convenient wrapper with a nicer interface for using regular\n * expressions or Express-style routes as the `match` criteria.\n *\n * @example\n * // Any navigate requests for URLs that start with /path/to/ will match.\n * const route = new workbox.routing.Route({\n *   match: ({url, event}) => {\n *     return event.request.mode === 'navigate' &&\n *            url.pathname.startsWith('/path/to/');\n *   },\n *   handler: ({event}) => {\n *     // Do something that returns a Promise.<Response>, like:\n *     return caches.match(event.request);\n *   },\n * });\n *\n * const router = new workbox.routing.Router();\n * router.registerRoute({route});\n *\n * @memberof module:workbox-routing\n */\nclass Route {\n  /**\n   * Constructor for Route class.\n   * @param {Object} input\n   * @param {function} input.match The function that determines whether the\n   * route matches a given `fetch` event.\n   *\n   * See [matchCallback]{@link module:workbox-routing.Route~matchCallback} for\n   * full details on this function.\n   * @param {function|module:workbox-runtime-caching.Handler} input.handler\n   * This parameter can be either a function or an object which is a subclass\n   * of `Handler`.\n   *\n   * Either option should result in a `Response` that the `Route` can use to\n   * handle the `fetch` event.\n   *\n   * See [handlerCallback]{@link module:workbox-routing.Route~handlerCallback}\n   * for full details on using a callback function as the `handler`.\n   * @param {string} [input.method] Only match requests that use this\n   * HTTP method.\n   *\n   * Defaults to `'GET'`.\n   */\n  constructor({match, handler, method} = {}) {\n    this.handler = normalizeHandler(handler);\n\n    isType({match}, 'function');\n    this.match = match;\n\n    if (method) {\n      isOneOf({method}, validMethods);\n      this.method = method;\n    } else {\n      this.method = defaultMethod;\n    }\n  }\n}\n\nexport default Route;\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport ErrorFactory from './error-factory';\nimport Route from './route';\nimport pathToRegExp from 'path-to-regexp';\n\n/**\n * `ExpressRoute` is a helper class to make defining Express-style\n * [Routes]{@link module:workbox-routing.Route} easy.\n *\n * Under the hood, it uses the [`path-to-regexp`](https://www.npmjs.com/package/path-to-regexp)\n * library to transform the `path` parameter into a regular expression, which is\n * then matched against the URL's path.\n *\n * Please note that `ExpressRoute` can match either same-origin or cross-origin\n * requests.\n *\n * To match same-origin requests, use a `path` value that begins with\n * `'/'`, e.g. `'/path/to/:file'`.\n *\n * To match cross-origin requests, use a `path` value that includes the origin,\n * e.g. `'https://example.com/path/to/:file'`.\n *\n * @example\n * // Any same-origin requests that start with /path/to and end with one\n * // additional path segment will match this route, with the last path\n * // segment passed along to the handler via params.file.\n * const route = new workbox.routing.ExpressRoute({\n *   path: '/path/to/:file',\n *   handler: ({event, params}) => {\n *     // params.file will be set based on the request URL that matched.\n *     return caches.match(params.file);\n *   },\n * });\n *\n * const router = new workbox.routing.Router();\n * router.registerRoute({route});\n *\n * @example\n * // Any cross-origin requests for https://example.com will match this route.\n * const route = new workbox.routing.ExpressRoute({\n *   path: 'https://example.com/path/to/:file',\n *   handler: ({event}) => return caches.match(event.request),\n * });\n *\n * const router = new workbox.routing.Router();\n * router.registerRoute({route});\n *\n * @memberof module:workbox-routing\n * @extends Route\n */\nclass ExpressRoute extends Route {\n  /**\n   * Constructor for ExpressRoute.\n   *\n   * @param {Object} input\n   * @param {String} input.path The path to use for routing.\n   * If the path contains [named parameters](https://github.com/pillarjs/path-to-regexp#named-parameters),\n   * then an Object that maps parameter names to their corresponding value\n   * will be passed to the handler via `params`.\n   * @param {function|module:workbox-runtime-caching.Handler} input.handler The\n   * handler to use to provide a response if the route matches.\n   *\n   * If you wish to use a callback function [see handlerCallback]{@link\n   *   module:workbox-routing.Route~handlerCallback} for the callback\n   * definition.\n   * @param {string} [input.method] Only match requests that use this\n   * HTTP method.\n   *\n   * Defaults to `'GET'`.\n   */\n  constructor({path, handler, method}) {\n    if (!(path.startsWith('/') || path.startsWith('http'))) {\n      throw ErrorFactory.createError('express-route-invalid-path');\n    }\n\n    let keys = [];\n    // keys is populated as a side effect of pathToRegExp. This isn't the nicest\n    // API, but so it goes.\n    // https://github.com/pillarjs/path-to-regexp#usage\n    const regExp = pathToRegExp(path, keys);\n    const match = ({url}) => {\n      // A path starting with '/' is a signal that we only want to match\n      // same-origin. Bail out early if needed.\n      if (path.startsWith('/') && url.origin !== location.origin) {\n        return null;\n      }\n\n      // We need to match on either just the pathname or the full URL, depending\n      // on whether the path parameter starts with '/' or 'http'.\n      const pathNameOrHref = path.startsWith('/') ? url.pathname : url.href;\n      const regexpMatches = pathNameOrHref.match(regExp);\n      // Return null immediately if this route doesn't match.\n      if (!regexpMatches) {\n        return null;\n      }\n\n      // If the route does match, then collect values for all the named\n      // parameters that were returned in keys.\n      // If there are no named parameters then this will end up returning {},\n      // which is truthy, and therefore a sufficient return value.\n      const namedParamsToValues = {};\n      keys.forEach((key, index) => {\n        namedParamsToValues[key.name] = regexpMatches[index + 1];\n      });\n\n      return namedParamsToValues;\n    };\n\n    super({match, handler, method});\n  }\n}\n\nexport default ExpressRoute;\n","/* eslint-disable no-console */\n\n/**\n * A simple helper to manage the print of a set of logs\n */\nclass LogGroup {\n  /**\n   * @param {object} input\n   */\n  constructor() {\n    this._logs = [];\n    this._childGroups = [];\n\n    this._isFallbackMode = false;\n    const ffRegex = /Firefox\\/(\\d*)\\.\\d*/.exec(navigator.userAgent);\n    if (ffRegex) {\n      try {\n        const ffVersion = parseInt(ffRegex[1], 10);\n        if (ffVersion < 55) {\n          this._isFallbackMode = true;\n        }\n      } catch (err) {\n        this._isFallbackMode = true;\n      }\n    }\n\n    if (/Edge\\/\\d*\\.\\d*/.exec(navigator.userAgent)) {\n      this._isFallbackMode = true;\n    }\n  }\n\n  /**\n   *@param {object} logDetails\n   */\n  addPrimaryLog(logDetails) {\n    this._primaryLog = logDetails;\n  }\n\n  /**\n   *@param {object} logDetails\n   */\n  addLog(logDetails) {\n    this._logs.push(logDetails);\n  }\n\n  /**\n   * @param {object} group\n   */\n  addChildGroup(group) {\n    if (group._logs.length === 0) {\n      return;\n    }\n\n    this._childGroups.push(group);\n  }\n\n  /**\n   * prints out this log group to the console.\n   */\n  print() {\n    if (this._logs.length === 0 && this._childGroups.length === 0) {\n      this._printLogDetails(this._primaryLog);\n      return;\n    }\n\n    if (this._primaryLog) {\n      if (!this._isFallbackMode) {\n        console.groupCollapsed(...this._getLogContent(this._primaryLog));\n      } else {\n        this._printLogDetails(this._primaryLog);\n      }\n    }\n\n    this._logs.forEach((logDetails) => {\n      this._printLogDetails(logDetails);\n    });\n\n    this._childGroups.forEach((group) => {\n      group.print();\n    });\n\n    if (this._primaryLog && !this._isFallbackMode) {\n      console.groupEnd();\n    }\n  }\n\n  /**\n   * Prints the specific logDetails object.\n   * @param {object} logDetails\n   */\n  _printLogDetails(logDetails) {\n    const logFunc = logDetails.logFunc ? logDetails.logFunc : console.log;\n    logFunc(...this._getLogContent(logDetails));\n  }\n\n  /**\n   * Returns a flattened array of message with colors and args.\n   * @param {object} logDetails\n   * @return {Array} Returns an array of arguments to pass to a console\n   * function.\n   */\n  _getLogContent(logDetails) {\n    let message = logDetails.message;\n    if (this._isFallbackMode && typeof message === 'string') {\n      // Replace the %c value with an empty string.\n      message = message.replace(/%c/g, '');\n    }\n\n    let allArguments = [message];\n\n    if (!this._isFallbackMode && logDetails.colors) {\n      allArguments = allArguments.concat(logDetails.colors);\n    }\n\n    if (logDetails.args) {\n      allArguments = allArguments.concat(logDetails.args);\n    }\n    return allArguments;\n  }\n}\n\nexport default LogGroup;\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/**\n * @private\n * @return {boolean} True, if we're running in the service worker global scope.\n * False otherwise.\n */\nexport function isServiceWorkerGlobalScope() {\n  return ('ServiceWorkerGlobalScope' in self &&\n          self instanceof ServiceWorkerGlobalScope);\n}\n\n/**\n * @private\n * @return {boolean} True, if we're running a development bundle.\n * False otherwise.\n */\nexport function isDevBuild() {\n  // `BUILD_PROCESS_REPLACE::BUILD_TARGET` is replaced during the build process.\n  return `BUILD_PROCESS_REPLACE::BUILD_TARGET` === `dev`;\n}\n\n/**\n * @private\n * @return {boolean} True, if we're running on localhost or the equivalent IP\n * address. False otherwise.\n */\nexport function isLocalhost() {\n  return Boolean(\n    location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n  );\n}\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/* eslint-disable no-console */\n\nimport LogGroup from './log-group';\nimport {isDevBuild} from './environment';\n\nself.workbox = self.workbox || {};\nself.workbox.LOG_LEVEL = self.workbox.LOG_LEVEL || {\n  none: -1,\n  verbose: 0,\n  debug: 1,\n  warn: 2,\n  error: 3,\n};\n\nconst LIGHT_GREY = `#bdc3c7`;\nconst DARK_GREY = `#7f8c8d`;\nconst LIGHT_GREEN = `#2ecc71`;\nconst LIGHT_YELLOW = `#f1c40f`;\nconst LIGHT_RED = `#e74c3c`;\nconst LIGHT_BLUE = `#3498db`;\n\n/**\n * A class that will only log given the current log level\n * defined by the developer.\n *\n * Define custom log level by setting `self.workbox.logLevel`.\n *\n * @example\n *\n * self.workbox.logLevel = self.workbox.LOG_LEVEL.verbose;\n *\n * @private\n */\nclass LogHelper {\n  /**\n   * LogHelper constructor.\n   */\n  constructor() {\n    this._defaultLogLevel = isDevBuild() ?\n      self.workbox.LOG_LEVEL.debug :\n      self.workbox.LOG_LEVEL.warn;\n  }\n\n  /**\n   * The most verbose log level.\n   *\n   * @param {Object} options The options of the log.\n   */\n  log(options) {\n    this._printMessage(self.workbox.LOG_LEVEL.verbose, options);\n  }\n\n  /**\n   * Useful for logs that are more exceptional that log()\n   * but not severe.\n   *\n   * @param {Object} options The options of the log.\n   */\n  debug(options) {\n    this._printMessage(self.workbox.LOG_LEVEL.debug, options);\n  }\n\n  /**\n   * Warning messages.\n   *\n   * @param {Object} options The options of the log.\n   */\n  warn(options) {\n    this._printMessage(self.workbox.LOG_LEVEL.warn, options);\n  }\n\n  /**\n   * Error logs.\n   *\n   * @param {Object} options The options of the log.\n   */\n  error(options) {\n    this._printMessage(self.workbox.LOG_LEVEL.error, options);\n  }\n\n  /**\n   * Method to print to the console.\n   * @param {number} logLevel\n   * @param {Object} logOptions\n   */\n  _printMessage(logLevel, logOptions) {\n    if (!this._shouldLogMessage(logLevel, logOptions)) {\n      return;\n    }\n\n    const logGroups = this._getAllLogGroups(logLevel, logOptions);\n    logGroups.print();\n  }\n\n  /**\n   * Print a user friendly log to the console.\n   * @param  {numer} logLevel A number from self.workbox.LOG_LEVEL\n   * @param  {Object} logOptions Arguments to print to the console\n   * @return {LogGroup} Returns a log group to print to the console.\n   */\n  _getAllLogGroups(logLevel, logOptions) {\n    const topLogGroup = new LogGroup();\n\n    const primaryMessage = this._getPrimaryMessageDetails(logLevel, logOptions);\n    topLogGroup.addPrimaryLog(primaryMessage);\n\n    if (logOptions.error) {\n      const errorMessage = {\n        message: logOptions.error,\n        logFunc: console.error,\n      };\n      topLogGroup.addLog(errorMessage);\n    }\n\n    const extraInfoGroup = new LogGroup();\n    if (logOptions.that && logOptions.that.constructor &&\n      logOptions.that.constructor.name) {\n      const className = logOptions.that.constructor.name;\n      extraInfoGroup.addLog(\n        this._getKeyValueDetails('class', className)\n      );\n    }\n\n    if (logOptions.data) {\n      if (typeof logOptions.data === 'object' &&\n        !(logOptions.data instanceof Array)) {\n        Object.keys(logOptions.data).forEach((keyName) => {\n          extraInfoGroup.addLog(\n            this._getKeyValueDetails(keyName, logOptions.data[keyName])\n          );\n        });\n      } else {\n        extraInfoGroup.addLog(\n          this._getKeyValueDetails('additionalData', logOptions.data)\n        );\n      }\n    }\n\n    topLogGroup.addChildGroup(extraInfoGroup);\n\n    return topLogGroup;\n  }\n\n  /**\n   * This is a helper function to wrap key value pairss to a colored key\n   * value string.\n   * @param  {string} key\n   * @param  {string} value\n   * @return {Object} The object containing a message, color and Arguments\n   * for the console.\n   */\n  _getKeyValueDetails(key, value) {\n    return {\n      message: `%c${key}: `,\n      colors: [`color: ${LIGHT_BLUE}`],\n      args: value,\n    };\n  }\n\n  /**\n   * Helper method to color the primary message for the log\n   * @param  {number} logLevel   One of self.workbox.LOG_LEVEL\n   * @param  {Object} logOptions Arguments to print to the console\n   * @return {Object} Object containing the message and color info to print.\n   */\n  _getPrimaryMessageDetails(logLevel, logOptions) {\n    let logLevelName;\n    let logLevelColor;\n    switch (logLevel) {\n      case self.workbox.LOG_LEVEL.verbose:\n        logLevelName = 'Info';\n        logLevelColor = LIGHT_GREY;\n        break;\n      case self.workbox.LOG_LEVEL.debug:\n        logLevelName = 'Debug';\n        logLevelColor = LIGHT_GREEN;\n        break;\n      case self.workbox.LOG_LEVEL.warn:\n        logLevelName = 'Warn';\n        logLevelColor = LIGHT_YELLOW;\n        break;\n      case self.workbox.LOG_LEVEL.error:\n        logLevelName = 'Error';\n        logLevelColor = LIGHT_RED;\n        break;\n    }\n\n    let primaryLogMessage = `%cðŸ”§ %c[${logLevelName}]`;\n    const primaryLogColors = [\n      `color: ${LIGHT_GREY}`,\n      `color: ${logLevelColor}`,\n    ];\n\n    let message;\n    if (typeof logOptions === 'string') {\n      message = logOptions;\n    } else if (logOptions.message) {\n      message = logOptions.message;\n    }\n\n    if (message) {\n      message = message.replace(/\\s+/g, ' ');\n      primaryLogMessage += `%c ${message}`;\n      primaryLogColors.push(`color: ${DARK_GREY}; font-weight: normal`);\n    }\n\n    return {\n      message: primaryLogMessage,\n      colors: primaryLogColors,\n    };\n  }\n\n  /**\n   * Test if the message should actually be logged.\n   * @param {number} logLevel The level of the current log to be printed.\n   * @param {Object|String} logOptions The options to log.\n   * @return {boolean} Returns true of the message should be printed.\n   */\n  _shouldLogMessage(logLevel, logOptions) {\n    if (!logOptions) {\n      return false;\n    }\n\n    let minValidLogLevel = this._defaultLogLevel;\n    if (self && self.workbox && typeof self.workbox.logLevel === 'number') {\n      minValidLogLevel = self.workbox.logLevel;\n    }\n\n    if (minValidLogLevel === self.workbox.LOG_LEVEL.none ||\n      logLevel < minValidLogLevel) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\nexport default new LogHelper();\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n\nimport Route from './route';\nimport {isArrayOfClass} from '../../../../lib/assert';\nimport logHelper from '../../../../lib/log-helper';\n\n/**\n * NavigationRoute is a helper class to create a [Route]{@link\n * module:workbox-routing.Route} that matches for browser navigation requests,\n * i.e. requests for HTML pages.\n *\n * It will only match incoming requests whose [`mode`](https://fetch.spec.whatwg.org/#concept-request-mode)\n * is set to `navigate`.\n *\n * You can optionally only apply this route to a subset of navigation requests\n * by using one or both of the `blacklist` and `whitelist` parameters. If\n * both lists are provided, and there's a navigation to a URL which matches\n * both, then the blacklist will take precedence and the request will not be\n * matched by this route. The regular expressions in `whitelist` and `blacklist`\n * are matched against the concatenated\n * [`pathname`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname)\n * and [`search`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search)\n * portions of the requested URL.\n *\n * To match all navigations, use a `whitelist` array containing a RegExp that\n * matches everything, i.e. `[/./]`.\n *\n * @memberof module:workbox-routing\n * @extends Route\n *\n * @example\n * // Any navigation requests that match the whitelist (i.e. URLs whose path\n * // starts with /article/) will be handled with the cache entry for\n * // app-shell.html.\n * const route = new workbox.routing.NavigationRoute({\n *   whitelist: [new RegExp('^/article/')],\n *   handler: {handle: () => caches.match('app-shell.html')},\n * });\n *\n * const router = new workbox.routing.Router();\n * router.registerRoute({route});\n */\nclass NavigationRoute extends Route {\n  /**\n   * Constructor for NavigationRoute.\n   *\n   * @param {Object} input\n   * @param {Array<RegExp>} input.whitelist If any of these patterns match,\n   * the route will handle the request (assuming the blacklist doesn't match).\n   * @param {Array<RegExp>} [input.blacklist] If any of these patterns match,\n   * the route will not handle the request (even if a whitelist entry matches).\n   * @param {function|module:workbox-runtime-caching.Handler} input.handler The\n   * handler to use to provide a response if the route matches.\n   *\n   * If you wish to use a callback function [see handlerCallback]{@link\n   *   module:workbox-routing.Route~handlerCallback} for the callback\n   * definition.\n   */\n  constructor({whitelist, blacklist, handler} = {}) {\n    isArrayOfClass({whitelist}, RegExp);\n    if (blacklist) {\n      isArrayOfClass({blacklist}, RegExp);\n    } else {\n      blacklist = [];\n    }\n\n    const match = ({event, url}) => {\n      let matched = false;\n      let message;\n\n      if (event.request.mode === 'navigate') {\n        const pathnameAndSearch = url.pathname + url.search;\n        if (whitelist.some((regExp) => regExp.test(pathnameAndSearch))) {\n          if (blacklist.some((regExp) => regExp.test(pathnameAndSearch))) {\n            message = `The navigation route is not being used, since the ` +\n              `request URL matches both the whitelist and blacklist.`;\n          } else {\n            message = `The navigation route is being used.`;\n            matched = true;\n          }\n        } else {\n          message = `The navigation route is not being used, since the ` +\n            `URL being navigated to doesn't match the whitelist.`;\n        }\n\n        logHelper.debug({\n          that: this,\n          message,\n          data: {'request-url': url.href, whitelist, blacklist, handler},\n        });\n      }\n\n      return matched;\n    };\n\n    super({match, handler, method: 'GET'});\n  }\n}\n\nexport default NavigationRoute;\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport Route from './route';\nimport {isInstance} from '../../../../lib/assert';\nimport logHelper from '../../../../lib/log-helper.js';\n\n/**\n * RegExpRoute is a helper class to make defining regular expression based\n * [Routes]{@link module:workbox-routing.Route} easy.\n *\n * The matching for regular expressioned are slightly different between\n * same-origin requests and cross-origin requests.\n *\n * A common pattern is to use a regex pattern similar to `/styles/.*` to capture\n * all stylesheets on your site.\n *\n * If we used this on `https://workboxjs.org`,\n * this regular expression would match for the end of\n * <code>https://workboxjs.org<strong>/styles/main.css</strong></code>.\n *\n * However, it's unlikely that we'd intend for this to match against:\n * <code>https://third-party-origin.com<strong>/styles/example.css</strong></code>.\n *\n * To overcome this common issue, regular expressions will only match against\n * cross-origin requests if the regular expression matches from the start.\n *\n * For example, matching the cross-origin example, we could change the\n * regular expression to: `https://third-party-origin.com/styles/.*`, meaning\n * we would now match <code><strong>https://third-party-origin.com/styles/example.css</strong></code>.\n *\n * If you wish your regular expression to match both, you just need to ensure\n * you account for the full URL.\n *\n * @memberof module:workbox-routing\n * @extends Route\n *\n * @example\n * // Any requests that match the regular expression will match this route, with\n * // the capture groups passed along to the handler as an array via params.\n * const route = new workbox.routing.RegExpRoute({\n *   regExp: new RegExp('^https://example.com/path/to/(\\\\w+)'),\n *   handler: {\n *     handle: ({event, params}) => {\n *       // params[0], etc. will be set based on the regexp capture groups.\n *       // Do something that returns a Promise.<Response>, like:\n *       return caches.match(event.request);\n *     },\n *   },\n * });\n *\n * const router = new workbox.routing.Router();\n * router.registerRoute({route});\n */\nclass RegExpRoute extends Route {\n  /**\n   * Constructor for RegExpRoute.\n   *\n   * @param {Object} input\n   * @param {RegExp} input.regExp The regular expression to match against URLs.\n   * If the `RegExp` contains [capture groups](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references),\n   * then the array of captured values will be passed to the `handler` as\n   * `params`.\n   * @param {function|module:workbox-runtime-caching.Handler} input.handler The\n   * handler to use to provide a response if the route matches.\n   *\n   * If you wish to use a callback function [see handlerCallback]{@link\n   *   module:workbox-routing.Route~handlerCallback} for the callback\n   * definition.\n   * @param {string} [input.method] Only match requests that use this\n   * HTTP method. Defaults to `'GET'` if not specified.\n   */\n  constructor({regExp, handler, method}) {\n    isInstance({regExp}, RegExp);\n\n    const match = ({url}) => {\n      const result = regExp.exec(url.href);\n\n      // Return null immediately if this route doesn't match.\n      if (!result) {\n        return null;\n      }\n\n      // If this is a cross-origin request, then confirm that the match included\n      // the start of the URL. This means that regular expressions like\n      // /styles.+/ will only match same-origin requests.\n      // See https://github.com/GoogleChrome/workbox/issues/281#issuecomment-285130355\n      if ((url.origin !== location.origin) && (result.index !== 0)) {\n        logHelper.debug({\n          that: this,\n          message: `Skipping route, because the RegExp match didn't occur ` +\n            `at the start of the URL.`,\n          data: {url: url.href, regExp},\n        });\n\n        return null;\n      }\n\n      // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n      return result.slice(1);\n    };\n\n    super({match, handler, method});\n  }\n}\n\nexport default RegExpRoute;\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport Route from './route';\nimport {isArrayOfClass, isInstance} from '../../../../lib/assert';\nimport logHelper from '../../../../lib/log-helper.js';\nimport normalizeHandler from './normalize-handler';\n\n/**\n * The Router takes one or more [Routes]{@link Route} and allows you to apply\n * that routing logic to determine the appropriate way of handling requests\n * inside of a service worker.\n *\n * It also allows you to define a \"default\" handler that applies to any requests\n * that don't explicitly match a `Route`, and a \"catch\" handler that responds\n * to any requests that throw an exception while being routed.\n *\n * You can use the `handleRequest()` method to pass a `FetchEvent` through the\n * router and ultimately get a \"routed response\" back.\n * If you'd like this to be handled automatically for you, calling\n * `addFetchListener()` will cause the `Router` to respond to `fetch` events.\n *\n * @memberof module:workbox-routing\n *\n * @example\n * // The following example sets up two routes, one to match requests with\n * // \"assets\" in their URL, and the other for requests with \"images\", along\n * // different runtime caching handlers for each.\n * // Both the routes are registered with the router, and any requests that\n * // don't match either route will be handled using the default NetworkFirst\n * // strategy.\n * const assetRoute = new RegExpRoute({\n *   regExp: /assets/,\n *   handler: new workbox.runtimeCaching.StaleWhileRevalidate(),\n * });\n * const imageRoute = new RegExpRoute({\n *   regExp: /images/,\n *   handler: new workbox.runtimeCaching.CacheFirst(),\n * });\n *\n * const router = new workbox.routing.Router();\n * router.addFetchListener();\n * router.registerRoutes({routes: [assetRoute, imageRoute]});\n * router.setDefaultHandler({\n *   handler: new workbox.runtimeCaching.NetworkFirst(),\n * });\n */\nclass Router {\n  /**\n   * Constructs a new `Router` instance, without any registered routes.\n   */\n  constructor() {\n    // _routes will contain a mapping of HTTP method name ('GET', etc.) to an\n    // array of all the corresponding Route instances that are registered.\n    this._routes = new Map();\n    this._isListenerRegistered = false;\n  }\n\n  /**\n   * This will register a `fetch` event listener on your behalf which will check\n   * the incoming request to see if there's a matching route, and only respond\n   * if there is a match.\n   *\n   * @example\n   * const imageRoute = new RegExpRoute({\n   *   regExp: /images/,\n   *   handler: new CacheFirst(),\n   * });\n   *\n   * const router = new Router();\n   * router.registerRoute({route: imageRoute});\n   * router.addFetchListener();\n   *\n   * @return {boolean} Returns `true` if this is the first time the method is\n   * called and the listener was registered. Returns `false` if called again,\n   * as the listener will only be registered once.\n   */\n  addFetchListener() {\n    if (!this._isListenerRegistered) {\n      this._isListenerRegistered = true;\n      self.addEventListener('fetch', (event) => {\n        const responsePromise = this.handleRequest({event});\n        if (responsePromise) {\n          event.respondWith(responsePromise);\n        }\n      });\n      return true;\n    } else {\n      logHelper.warn({\n        that: this,\n        message: `addFetchListener() has already been called for this Router.`,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * This can be used to apply the routing rules to generate a response for a\n   * given request inside your own `fetch` event handler.\n   *\n   * @example\n   * const imageRoute = new RegExpRoute({\n   *   regExp: /images/,\n   *   handler: new CacheFirst(),\n   * });\n   *\n   * const router = new Router();\n   * router.registerRoute({route: imageRoute});\n   *\n   * self.addEventListener('fetch', (event) => {\n   *   event.waitUntil((async () => {\n   *     let response = await router.handleRequest({event});\n   *     // Do something with response, and then eventually respond with it.\n   *     event.respondWith(response);\n   *   })());\n   * });\n   *\n   * @param {Object} input\n   * @param {FetchEvent} input.event The event passed in to a `fetch` handler.\n   * @return {Promise<Response>|undefined} Returns a promise for a response,\n   * taking the registered routes into account. If there was no matching route\n   * and there's no `defaultHandler`, then returns undefined.\n   */\n  handleRequest({event}) {\n    isInstance({event}, FetchEvent);\n    const url = new URL(event.request.url);\n    if (!url.protocol.startsWith('http')) {\n      logHelper.log({\n        that: this,\n        message: `The URL does not start with HTTP, so it can't be handled.`,\n        data: {\n          request: event.request,\n        },\n      });\n      return;\n    }\n\n    let {handler, params} = this._findHandlerAndParams({event, url});\n\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    if (!handler && this.defaultHandler) {\n      handler = this.defaultHandler;\n    }\n\n    if (handler) {\n      let responsePromise = handler.handle({url, event, params});\n      if (this.catchHandler) {\n        responsePromise = responsePromise.catch((error) => {\n          return this.catchHandler.handle({url, event, error});\n        });\n      }\n      return responsePromise;\n    }\n  }\n\n  /**\n   * Checks the incoming event.request against the registered routes, and if\n   * there's a match, returns the corresponding handler along with any params\n   * generated by the match.\n   *\n   * @param {FetchEvent} input.event\n   * @param {URL} input.url\n   * @return {Object} Returns an object with `handler` and `params` properties.\n   * They are populated if a matching route was found or `undefined` otherwise.\n   * @private\n   */\n  _findHandlerAndParams({event, url}) {\n    const routes = this._routes.get(event.request.method) || [];\n    for (const route of routes) {\n      let matchResult = route.match({url, event});\n      if (matchResult) {\n        logHelper.log({\n          that: this,\n          message: 'The router found a matching route.',\n          data: {\n            route,\n            request: event.request,\n          },\n        });\n\n        if (Array.isArray(matchResult) && matchResult.length === 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          matchResult = undefined;\n        } else if (matchResult.constructor === Object &&\n          Object.keys(matchResult).length === 0) {\n          // Instead of passing an empty object in as params, use undefined.\n          matchResult = undefined;\n        }\n\n        // Break out of the loop and return the appropriate values as soon as\n        // we have a match.\n        return {\n          params: matchResult,\n          handler: route.handler,\n        };\n      }\n    }\n\n    // If we didn't have a match, then return undefined values.\n    return {handler: undefined, params: undefined};\n  }\n\n  /**\n   * An optional `handler` that's called by default when no routes\n   * explicitly match the incoming request.\n   *\n   * If the default is not provided, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @example\n   * router.setDefaultHandler({\n   *   handler: new workbox.runtimeCaching.NetworkFirst()\n   * });\n   *\n   * @param {Object} input\n   * @param {function|module:workbox-runtime-caching.Handler} input.handler\n   * This parameter can be either a function or an object which is a subclass\n   * of `Handler`.\n   *\n   * Either option should result in a `Response` that the `Route` can use to\n   * handle the `fetch` event.\n   *\n   * See [handlerCallback]{@link module:workbox-routing.Route~handlerCallback}\n   * for full details on using a callback function as the `handler`.\n   */\n  setDefaultHandler({handler} = {}) {\n    this.defaultHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @example\n   * router.setCatchHandler(({event}) => {\n   *   if (event.request.mode === 'navigate') {\n   *     return caches.match('/error-page.html');\n   *   }\n   *   return Response.error();\n   * });\n   *\n   * @param {Object} input\n   * @param {function|module:workbox-runtime-caching.Handler} input.handler\n   * This parameter can be either a function or an object which is a subclass\n   * of `Handler`.\n   *\n   * Either option should result in a `Response` that the `Route` can use to\n   * handle the `fetch` event.\n   *\n   * See [handlerCallback]{@link module:workbox-routing.Route~handlerCallback}\n   * for full details on using a callback function as the `handler`.\n   */\n  setCatchHandler({handler} = {}) {\n    this.catchHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * Registers an array of routes with the router.\n   *\n   * @example\n   * router.registerRoutes({\n   *   routes: [\n   *     new RegExpRoute({ ... }),\n   *     new ExpressRoute({ ... }),\n   *     new Route({ ... }),\n   *   ]\n   * });\n   *\n   * @param {Object} input\n   * @param {Array<module:workbox-routing.Route>} input.routes An array of\n   * routes to register.\n   */\n  registerRoutes({routes} = {}) {\n    isArrayOfClass({routes}, Route);\n\n    for (let route of routes) {\n      if (!this._routes.has(route.method)) {\n        this._routes.set(route.method, []);\n      }\n\n      // Give precedence to the most recent route by listing it first.\n      this._routes.get(route.method).unshift(route);\n    }\n  }\n\n  /**\n   * Registers a single route with the router.\n   *\n   * @example\n   * router.registerRoute({\n   *   route: new Route({ ... })\n   * });\n   *\n   * @param {Object} input\n   * @param {module:workbox-routing.Route} input.route The route to register.\n   */\n  registerRoute({route} = {}) {\n    isInstance({route}, Route);\n\n    this.registerRoutes({routes: [route]});\n  }\n\n  /**\n   * Unregisters an array of routes with the router.\n   *\n   * @example\n   * const firstRoute = new RegExpRoute({ ... });\n   * const secondRoute = new RegExpRoute({ ... });\n   * router.registerRoutes({routes: [firstRoute, secondRoute]});\n   *\n   * // Later, if you no longer want the routes to be used:\n   * router.unregisterRoutes({routes: [firstRoute, secondRoute]});\n   *\n   * @param {Object} input\n   * @param {Array<module:workbox-routing.Route>} input.routes An array of\n   * routes to unregister.\n   */\n  unregisterRoutes({routes} = {}) {\n    isArrayOfClass({routes}, Route);\n\n    for (let route of routes) {\n      if (!this._routes.has(route.method)) {\n        logHelper.error({\n          that: this,\n          message: `Can't unregister route; there are no ${route.method}\n            routes registered.`,\n          data: {route},\n        });\n      }\n\n      const routeIndex = this._routes.get(route.method).indexOf(route);\n      if (routeIndex > -1) {\n        this._routes.get(route.method).splice(routeIndex, 1);\n      } else {\n        logHelper.error({\n          that: this,\n          message: `Can't unregister route; the route wasn't previously\n            registered.`,\n          data: {route},\n        });\n      }\n    }\n  }\n\n  /**\n   * Unregisters a single route with the router.\n   *\n   * @example\n   * const route = new RegExpRoute({ ... });\n   * router.registerRoute({route});\n   *\n   * // Later, if you no longer want the route to be used:\n   * router.unregisterRoute({route});\n   *\n   * @param {Object} input\n   * @param {module:workbox-routing.Route} input.route The route to unregister.\n   */\n  unregisterRoute({route} = {}) {\n    isInstance({route}, Route);\n\n    this.unregisterRoutes({routes: [route]});\n  }\n}\n\nexport default Router;\n"],"names":["constructor","_errors","errors","createError","name","replace","thrownError","message","stack","generatedError","parse","Object","keys","object","pop","parameter","expectedMethod","throwError","expectedClass","values","includes","actualType","expectedType","Array","isArray","item","error","ErrorStackParser","length","stackFrames","functionName","hasMethod","handler","isType","handle","match","method","normalizeHandler","isOneOf","validMethods","defaultMethod","prototype","toString","call","arr","pathToRegexp","compile","tokensToFunction","tokensToRegExp","PATH_REGEXP","join","options","delimiter","exec","str","res","index","slice","offset","m","escaped","path","tokens","push","defaultDelimiter","capture","group","prefix","optional","repeat","partial","next","asterisk","pattern","escapeGroup","escapeString","substr","c","charCodeAt","toUpperCase","i","matches","obj","opts","pretty","encodeURIComponentPretty","encodeURIComponent","token","data","isarray","value","JSON","stringify","j","encode","test","segment","encodeAsterisk","re","sensitive","source","groups","parts","flags","regexp","strict","end","route","endsWithDelimiter","attachKeys","regexpToRegexp","arrayToRegexp","stringToRegexp","startsWith","pathToRegExp","url","origin","location","pathname","href","pathNameOrHref","regExp","regexpMatches","forEach","namedParamsToValues","key","_logs","_childGroups","_isFallbackMode","navigator","userAgent","ffRegex","parseInt","addPrimaryLog","_primaryLog","logDetails","addLog","addChildGroup","print","_printLogDetails","console","groupCollapsed","_getLogContent","groupEnd","logFunc","log","colors","allArguments","concat","args","self","workbox","LOG_LEVEL","none","verbose","debug","warn","DARK_GREY","LIGHT_GREEN","LIGHT_YELLOW","LIGHT_RED","LIGHT_BLUE","_defaultLogLevel","isDevBuild","_printMessage","_shouldLogMessage","logLevel","logOptions","_getAllLogGroups","logGroups","_getPrimaryMessageDetails","topLogGroup","primaryMessage","errorMessage","that","extraInfoGroup","_getKeyValueDetails","className","keyName","LIGHT_GREY","logLevelName","logLevelColor","primaryLogColors","primaryLogMessage","minValidLogLevel","whitelist","blacklist","isArrayOfClass","RegExp","event","request","mode","search","some","pathnameAndSearch","logHelper","isInstance","result","_routes","_isListenerRegistered","addFetchListener","addEventListener","handleRequest","responsePromise","respondWith","FetchEvent","protocol","params","_findHandlerAndParams","defaultHandler","catchHandler","catch","get","matchResult","setDefaultHandler","setCatchHandler","registerRoutes","routes","Route","has","set","unshift","registerRoute","unregisterRoutes","indexOf","splice","routeIndex","unregisterRoute"],"mappings":"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"}