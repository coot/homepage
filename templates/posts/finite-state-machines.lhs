---
layout: post
title: "Finite-State Machines, Category Theoretical Perspective"
date: 28-08-2018
author: Marcin Szamotulski
categories: finite-state-machines
tags: ["haskell", "functional", "type-systems"]
excerpt: |
    Finite state machines are graphs, which generate a category.  We explore
    this point of using free algebra approach and tagless-final style.
---

> {-# LANGUAGE GADTs #-}
> {-# LANGUAGE FlexibleContexts #-}
> {-# LANGUAGE FlexibleInstances #-}
> {-# LANGUAGE InstanceSigs #-}
> {-# LANGUAGE KindSignatures #-}
> {-# LANGUAGE RankNTypes #-}
> {-# LANGUAGE ScopedTypeVariables #-}

> module Control.Category.FSM where

Typed Finite State Machines
===========================

In this post we will explore finite state machines with typed transitions
represented as finite directed graphs via free categories.

> import           Prelude hiding (id, foldMap, (.))

> import           Control.Arrow (Kleisli (..))
> import           Control.Category (Category (..), (<<<))
> import           Data.Bifunctor (Bifunctor (..))
> import           Data.List.NonEmpty (NonEmpty (..), (<|))
> import qualified Data.List.NonEmpty as NE
> import           Data.Void (Void)

Free Category Construction
--------------------------

A free category generated by a (directed) graph is formed by adding identity
edges for each vertex and then taking the graph of all possible paths in this
graph, i.e every path in this graph, becomes arrow in the generated category.
Composition of arrows is just composition of paths.  Note that this
construction correponds exactly to the construction of the free monoid: if
you take a graph with a single vertex `*` and a bunch of edges from `*` to
`*` then the free monoid generated by this set of edges is the same as the
free category (every monoid can be seen as a category with a single object).

> data Cat :: (* -> * -> *) -> * -> * -> * where
>     Id :: Cat f a a
>     (:.:) :: f b c -> Cat f a b -> Cat f a c

> instance Category (Cat f) where
>     id = Id
>     Id . ys = ys
>     (x :.: xs) . ys = x :.: (xs . ys)

As all the free constructions, alse free category has the lift operation which
let you embed the generating graph into the free category generated by it (it's a generalisation of the singleton list `a -> [a]`).

> liftCat :: f a b -> Cat f a b
> liftCat fab = fab :.: Id

Being a free category means that whenever you have a binatural transformation
from `f :: * -> * -> *` to a category `Category g => g :: * -> * -> *` you have
a unique functor from `Cat f` to `g`.  This is the spirit of free algebras.
And indeed we can get a `foldMap` like map:

> foldFunCat
>     :: forall f g a b . Category g
>     => (forall x y. f x y -> g x y)
>     -- ^ a map of graphs
>     -> (Cat f a b -> g a b)
>     -- ^ a functor from 'Cat f' to 'g'
> foldFunCat _ Id = id
> foldFunCat fun (fbc :.: cab)
>   = fun fbc . foldFunCat fun cab

As an example let us consder a bifunctor with a single object:

> data Const c a b where
>   Const :: c -> Const c c c 

Then we have an isomorphism

> toList :: Cat (Const c) c c -> [c]
> toList Id               = []
> toList (Const c :.: cs) = c : toList cs

With an inverse

> fromList :: [c] -> Cat (Const c) c c
> fromList []       = Id
> fromList (c : cs) = Const c :.: fromList cs

`foldFunCat` is nothing than a `foldMap`:

> foldMap :: Monoid m => (a -> m) -> [a] -> m
> foldMap _ [] = mempty
> foldMap f (a : as) = f a <> foldMap f as

One cannot write a `Category` instance for
`Monoid c => Const c`, though it's a perfectly fine category. One would need to
pattern match on type `a`, if
its `c` then we'd like to use `id = Const mempty` and otherwise `id = undefined`
could be a good choice:

> idConst :: Monoid c => Const c c c
> idConst = Const mempty

Similarly with composition:

> composeConst :: Monoid c => Const c c c -> Const c c c -> Const c c c
> composeConst (Const a) (Const b) = Const (a <> b)

Example Finite State Machine
----------------------------

For this post I picked the example of a state machine explored by Oscar
WickstrÃ¶m in his short series about state machines:
[part 1](https://wickstrom.tech/finite-state-machines/2017/11/10/finite-state-machines-part-1-modeling-with-haskell.html)
and
[part 2](https://wickstrom.tech/finite-state-machines/2017/11/19/finite-state-machines-part-2.html).
It is a simple state transition for an online shop.  I slightly simplified it,
by making the assumption that one can cancel at any stage
(just for presentation purposes).

States (vertices of the FSM):

> data NoItems       = NoItems
> newtype HasItems   = HasItems (NonEmpty CartItem)
> newtype NoCard     = NoCard (NonEmpty CartItem)
> data CardSelected  = CardSelected Card (NonEmpty CartItem)
> data CardConfirmed = CardConfirmed Card (NonEmpty CartItem)
> data OrderPlaced   = OrderPlaced

The shop only sells unit objects (better than seling `Void`s ;):

> type CartItem = ()

Accepted credit cards:

> type Card = String

Events (edges of the FSM).

> data Arrow s t where
>     SelectFirst :: CartItem -> Arrow NoItems HasItems
>     Select      :: CartItem -> Arrow HasItems HasItems
>     SelectCard  :: Card -> Arrow HasItems CardSelected
>     Confirm     :: Arrow CardSelected CardConfirmed
>     PlaceOrder  :: Arrow CardConfirmed OrderPlaced
>     Cancel      :: Arrow s NoItems

Category generated by the events

> type ShoppingCat a b = Cat Arrow a b

Interpretation of the `Arrow` graph in the `->` category:

> natPure :: Arrow a b -> a -> b
> natPure (SelectFirst i) _            = HasItems (i :| [])
> natPure (Select i) (HasItems is)     = HasItems (i <| is)
> natPure (SelectCard c) (HasItems is) = CardSelected c is
> natPure Confirm (CardSelected c is)  = CardConfirmed c is
> natPure PlaceOrder _                 = OrderPlaced
> natPure Cancel _                     = NoItems

Interpretation of `ShoppingCat` in `->`:

> checkoutPure :: ShoppingCat a b -> a -> b
> checkoutPure = foldFunCat natPure

But we can easily interpret in `ShoppingCat` in any Kleisli category,
especially in `Klesli IO`.  Here we lift just the pure interpretation, but
equaly well you could do some `IO` here.

> checkoutM :: forall m a b . Monad m => ShoppingCat a b -> Kleisli m a b
> checkoutM = foldFunCat nat
>     where
>     nat :: Arrow x y -> Kleisli m x y
>     nat arr = Kleisli (\a -> return $ natPure arr a)

Unpacking the `Kleisli` category gives us:

> runM :: Monad m => ShoppingCat a b -> a -> m b
> runM = runKleisli . checkoutM

Finally tagless description
---------------------------

> class Category c => ShoppingCatT (c :: * -> * -> *) where
>     selectFirst :: CartItem -> c NoItems HasItems
>     select      :: CartItem -> c HasItems HasItems
>     selectCard  :: Card -> c HasItems CardSelected
>     confirm     :: c CardSelected CardConfirmed
>     placeOrder  :: c CardConfirmed OrderPlaced
>     cancel      :: c s NoItems

`Cat Arrow` is the initial `ShoppingCatT` category.

> instance ShoppingCatT (Cat Arrow) where
>     selectFirst = liftCat . SelectFirst
>     select      = liftCat . Select
>     selectCard  = liftCat . SelectCard
>     confirm     = liftCat Confirm
>     placeOrder  = liftCat PlaceOrder
>     cancel      = liftCat Cancel

This is the unique functor `embed :: ShopingCatT c => ShoppingCat a b -> c a b`
which with preserves all the operations, e.g.

> -- embed (SelectFirst i) = selectFirst i 
> -- embed (Select i)      = select i
> -- embed (SelectCard v)  = selectCard v
> -- embed Confirm         = confirm
> -- embed PlaceOrder      = placeOrder
> -- embed Cancel          = cancel

This property does not leave any space how this functor has to be
implemented (that's why `ShoppingCat` is the initial object):

> embed :: forall c a b. ShoppingCatT c => ShoppingCat a b -> c a b
> embed = foldFunCat nat
>     where
>     nat :: Arrow x y -> c x y
>     nat (SelectFirst i) = selectFirst i
>     nat (Select i)      = select i
>     nat (SelectCard c)  = selectCard c
>     nat Confirm         = confirm
>     nat PlaceOrder      = placeOrder
>     nat Cancel          = cancel
