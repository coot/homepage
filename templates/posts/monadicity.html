{% extends "posts/base.html" %}

{% block main %}
<header>
    <h1 class="section_h" id="freeness-from-free-algebras-to-free-monads">Monadicity</h1>
    <h3>Monads in categorical algebra</h3>
</header>
    <p>
	In this post I'd like to introduce you to how mathematicians think
	about monads, and how they are useful.  We will study a general case
	alongside with a simple example of the category of monoids.  I hope you
	will get from this post how a monad describes category of monoids.  We
	will need some simple category theory tools like: adjoint functors,
	f-algebras, free algebras (or just free monoids) and monads.

	This blog post is based on a <a
	    href="https://hackage.haskell.org/package/free-algebras">library</a>
	I recently wrote, and it will use snippets of code from it.
    </p>
    Let <code>Monad</code> be the category of monads and <code>Hask</code> be
    the category of Haskell types.  There are two functors that connect this two categories:
    $$U:\mathrm{Monoid}\rightarrow\mathrm{Hask}$$
    which sends a monoid $m$ to its underlyaing type forgetting the $Monad$
    constraint; and the free monoid functor:
    $$F:\mathrm{Hask}\rightarrow\mathrm{Monoid}$$
    which takes a type $a$ and maps it to $[a]$, which is a monoid.  Let's
    try to analyse the relation ship between the two functors.  If you read
    my previous post on
    <a href="https://marcinszamotulski.me/posts/free-algebras">free algebras</a> 
    it won't be a surprise to you that there is a close relationship
    between these two constructions.  Lets put this in Haskell:
<pre class="haskell"><code>type family AlgebraType0 (f :: k) (a :: l) :: Constraint
type family AlgebraType (f :: k) (a :: l) :: Constraint
class FreeAlgebra (m :: (* -> *) -> * -> *) where
    -- | Injective map that embeds generators @a@ into @m@.
    returnFree :: a -> m a
    -- | The freeness property.
    foldMapFree
        :: forall d a
         . ( AlgebraType m d
           , AlgebraType0 m a
           )
        => (a -> d)   -- ^ map generators of @m@ into @d@
        -> (m a -> d) -- ^ returns a homomorphism from @m a@ to @d@

foldFree
    :: ( FreeAlgebra  m
       , AlgebraType0 m a
       , AlgebraType  m a
       )
    => m a
    -> a
foldFree = foldMapFree id

type instance AlgebraType0 [] a = ()
type instance AlgebraType  [] m = Monoid m
instance FreeAlgebra [] where
    returnFree a = [a]
    foldMapFree = foldMap
</code></pre>
    The type class <code>FreeAlgebra</code> has many more instances, e.g. for
    semigroups, groups, idempotent semigroups (semi-lattices), abelian
    semigroups / monoids / groups, and there is even a version for functors,
    applicative functors and monads.  For simplicity, in this post we will not
    touch the higher kinded types, but all of this works perfectly well for
    such data types too.

    You may ask what this type instance mean for monoids? We have two maps
<pre class="haskell"><code>returnFree @[] :: a -> [a]</code></pre>
    and a bijective map
<pre class="haskell"><code>foldMapFree @[] :: forall m a. Monoid m => (a -> m) -> ([a] -> m)</code></pre>
    given by <code>Prelude.foldMap</code> with inverse
<pre class="haskell"><code>unFoldMapFree
    :: FreeAlgebra m
    => (m a -> d)
    -> (a -> d)
unFoldMapFree f = f . returnFree
</code></pre>
    Note that <code>foldMapFree</code> has some nice properties:
    <ul>
	<li>For each <code>f :: Monoid m => a -> m</code> the map <code>foldMap f :: Monoid m => [a] -> m</code> is a homomorphism of monoids, i.e.
<pre class="haskell"><code>foldMap f (as <> bs) = foldMapFree f as <> foldMap f bs</code></pre>
	    This is simply because <code>foldMap</code> maps the elements of <code>as ::
		[a]</code> to a list of type <code>[m]</code> and the folds them using
	    monoid multiplication.  Being a monoid homomorphism in this case just means
	    that we can take two lists <code>as :: [a]</code> and <code>bs ::
	    [a]</code> and <code>foldMap</code> over both of them and then multiply the
	    results in <code>m</code> and we will get the same result as computing
	    <code>foldMap f (as ++ bs :: [a])</code>.  The result will be the same because
	    monoids satisfy the associativity law. 
	    <p>
		When you will define an instance of <code>FreeAlgebra</code>
		you should check that this law is obeyed.  Otherwise
		all the theory that we are uncovering here will fail.
	    </p>
	</li>
	<li>
	    <code>foldMap :: Monoid m => (a -> m) -> ([a] -> m)</code> is natural in <code>m</code> which in turn means that
<pre class="haskell"><code>foldMap (f . g) = f . foldMap g</code></pre>
	    For any map <code>g :: Monoid m => a -> m</code> and any monoid homomorphisms: <code>f :: (Monoid m, Monoid n) =>
		m -> n</code>.
	</li>
	<li>
	    <code>foldMap :: Monoid m => (a -> m) -> ([a] -> m)</code> is natural in <code>d</code> which means that
<pre class="haskell"><code>foldMap (g . h) = foldMap g . map h</code></pre>
	    For any map <code>h :: b -> a</code> and <code>g :: Monoid m =>
		a -> m</code>.
	</li>
    </ul>
    <p>
	The last two properties mean that <code>foldMapFree</code> (and
	<code>foldMap</code>) is a natural transformation of bifunctors from
	<code>Hom m</code> to <code>AlgHom m</code> which we define below.
<pre class="haskell"><code>data Hom m a b where
    Hom :: (AlgebraType0 m a, AlgebraType0 m b) => (a -> b) -> Hom m a b

bimapHom :: forall m a' a b b'.
            ( AlgebraType0 m a'
            , AlgebraType0 m b'
            )
         => (a' -> a)
         -> (b  -> b')
         -> Hom m a b
         -> Hom m a' b'
bimapHom f g (Hom ab) = Hom (g . ab . f)
</code></pre>
<pre class="haskell"><code>data AlgHom m a b where
    AlgHom :: ( AlgebraType0 m a
              , AlgebraType0 m b
              , AlgebraType  m a
              , AlgebraType  m b
              )
           => (a -> b)
           -> AlgHom m a b

unAlgHom :: AlgHom m a b -> a -> b
unAlgHom (AlgHom f) = f

bimapAlgHom :: forall m a' a b b'.
               ( AlgebraType0 m a'
               , AlgebraType0 m b'
               , AlgebraType  m a'
               , AlgebraType  m b'
               )
            => (a' -> a)
            -> (b  -> b')
            -> AlgHom m a b
            -> AlgHom m a' b'
bimapAlgHom f g (AlgHom ab) = AlgHom (g . ab . f)
</code></pre>
    </p>
    <p>
	Note that you could define (full sub-) categories using these bifunctors.
    </p>
    We can put all four properties (together with <code>foldMapFree</code>
    being a bijection), into single statement: <code>foldMapFree</code> is
    a natural isomorphism between <code>Hom m</code> and <code>AlgHom m</code>:
<pre class="haskell"><code>left :: forall m a d .
         ( FreeAlgebra  m
         , AlgebraType  m d
         , AlgebraType0 m a
         )
      => Hom m a d
      -> AlgHom m (m a) d
left (Hom f) = AlgHom $ foldMapFree f
</code></pre>
    with inverse
<pre class="haskell"><code>right :: forall m a d .
         ( FreeAlgebra  m
	 , AlgebraType  m d
         , AlgebraType0 m a
         )
      => AlgHom m (m a) d
      -> Hom m a d
right (AlgHom f) = Hom $ unFoldMapFree f
</code></pre>
    Such natural bijections arising for a pair of functors <code>F</code> and
    <code>U</code> are called <b>adjoint functors</b>.  In case of monoids the
    functor <code>F</code> is simply the list functor: <code>[]</code> functor
    and it is the left adjoin (it appears in the left argument of
    <code>AlgHom</code>) to the forgetful functor  from the category of monoids
    to <code>Hask</code> (it's on the right hand since of <code>Hom
	m a d</code> though in an invisible way, only because we are dropping
    a constraint).
    </p>

    <h2>Unit and counit of an adjunction</h2>
    <p>
	Every adjunction can be characterised by two maps called unit and counit.  The unit is defined as
<pre class="haskell"><code>unit :: forall m a .
         ( FreeAlgebra  m
         , AlgebraType0 m a
         )
      => Hom m a (m a)
unit = right (AlgHom id)
</code></pre>
and
<pre class="haskell"><code>counit :: forall m d .
          ( FreeAlgebra  m
          , AlgebraType  m d
          )
       => AlgHom m (m d) d
counit = left (Hom id)
</code></pre>
    Let us decipher these morphisms.  Let's start with <code>counit</code>
<pre class="haskell"><code>counit = right (AlgHom id)
       = Hom (foldMapFree id)
       = Hom foldFree
</code></pre>
    So this looks familiar!  In case of monoids this is just the good old
    friend <code>fold</code>. The <code>unit</code> is even simpler:
<pre class="haskell"><code>unit = left (AlgHom id)
     = unFoldMapFree id
     = returnFree
</code></pre>
    In case of monoids the unit is just <code>(:[]) :: a -> [a]</code>.

    <!-- TODO: Unit and counit satisfy two laws -->
    <h2>Monad associated with an adjunction</h2>
    Every adjunction gives rise to a monad.  The left adjoint functor followed
    by the right adjoint functor is an endofunctor and a monad.  In our case
    the left adjoin functor is the list functor <code>[]</code> from the
    <code>Hask</code> category to the category of monoids, while the right
    adjoin is the functor that forgets the <code>Monoid</code> constraint.  So
    the composition is simply the list functor: <code>(:[]) :: a -> [a]</code>

    I am sure you know that list is a monad, and it's the same monad as one
    given by the <code>(unAlgHom . counit) @[] :: [[a]] = [a]</code>.  This is a very
    general formula for constructing monads; actually any monad arise in this
    way: from a pair of adjoint functors; their <code>counit</code> morphism
    defined <code>join</code> and the <code>unit</code> defines
    <code>return</code>.  In the general case the monad structure is defined by
    the morphism <code>joinFree</code> which is just an alias for
    <code>foldFree</code>:
<pre class="haskell"><code>
-- |
-- @'FreeAlgebra'@ constraint implies @Monad@ constrain.
joinFree :: forall m a .
          ( FreeAlgebra  m
          , AlgebraType0 m a
          , AlgebraType0 m (m a)
          )
         => m (m a)
         -> m a
joinFree = foldFree mma
</code></pre>

<pre class="haskell"><code>
-- |
-- The composition of @F@ followed @U@
data FreeMAlg (m :: * -> *) (a :: *) where
    FreeMAlg :: FreeAlgebra m => m a -> FreeMAlg m a

runFreeMAlg :: FreeMAlg m a -> m a
runFreeMAlg (FreeMAlg ma) = ma

-- |
-- unit of the @FreeMAlg@ monad (i.e. @return@ in Haskell)
returnF :: forall m a .
           ( FreeAlgebra  m
           , AlgebraType0 m a
           , AlgebraType0 m (FreeMAlg m a)
           )
        => Hom m a (FreeMAlg m a)
returnF = case unit :: Hom m a (m a) of Hom f -> Hom (FreeMAlg . f)

-- |
-- join of the @FreeMAlg@ monad
joinF :: forall  m a .
         ( FreeAlgebra  m
         , AlgebraType0 m a
         , AlgebraType0 m (m a)
         , AlgebraType0 m (FreeMAlg m a)
         )
      => Hom m (FreeMAlg m (FreeMAlg m a)) (FreeMAlg m a)
joinF = Hom $ \(FreeMAlg mma) ->
    FreeMAlg $ joinFree $ fmapFree runFreeMAlg mma

-- |
-- bind of the @FreeMAlg@ monad
bindF :: forall m a b .
         ( FreeAlgebra  m
         , AlgebraType0 m b
         )
      => FreeMAlg m a
      -> Hom m a (FreeMAlg m b)
      -> FreeMAlg m b
bindF (FreeMAlg ma) (Hom f) = FreeMAlg $ ma `bindFree` (runFreeMAlg . f)
</code></pre>
    <h2>Algebras for a monad</h2>
    If <code>m</code> is a monad then an <code>m</code>-algebra is a map:
    <code>m a -> a</code>.  <code>m</code>-algebras form a category where
    arrows are commutative squares.
    <div class="diagram">
	<img src="/images/m-algebra-morphism.svg" width="200px" />
    </div>
    In Haskell this will fit into a simple type class:
<pre class="haskell"><code>class MAlg m a where
    alg :: m a -> a

instance MAlg [] [a] where
    alg = concat

instance MAlg NonEmpty (NonEmpty a) where
    alg = NE.fromList . concat . fmap NE.toList . NE.toList
</code></pre>
    You could define <code>MAlg</code> instance for <code>FreeMAlg</code> but
    we will avoid this.
<pre class="haskell"><code>instance (Monad m, FreeAlgebra m) => MAlg m (FreeMAlg m a) where
    alg ma = FreeMAlg $ join $ fmap runFreeMAlg ma
</code></pre>

    It turns out that <code>FreeMAlg m</code> is a left adjoin functor to the
    forgetful functor $\mathrm{U_{MAlg}}$ from the category of
    <code>m</code>-algebras to $\mathrm{Hask}$ which sends an
    <code>m</code>-agelbra <code>f :: m a ->
	a</code> to <code>a</code>.  This is simply because we can write
    <code>FreeAlgebra</code> instance for this type.  Well, not quite, only
    because Haskell does computes types families in a lazy way, but we can define all the
    morphisms we need:
<pre class="haskell"><code>returnFreeMAlg
    :: ( FreeAlgebra m
       , AlgebraType0 m a
       )
    => a
    -> FreeMAlg m a
returnFreeMAlg = FreeMAlg . returnFree

foldMapFreeMAlg
    :: ( AlgebraType0 m a
       , AlgebraType0 m d
       , MAlg m d
       )
    => (a -> d)
    -> (FreeMAlg m a -> d)
foldMapFreeMAlg fn (FreeMAlg ma) = alg $ fmapFree fn ma

foldFreeMAlg
    :: ( AlgebraType0 m a
       , MAlg m a
       ) 
    => FreeMAlg m a -> a
foldFreeMAlg = foldMapFreeMAlg id
</code></pre>
    We're kind of at the starting point of this post again.  Since we have an
    instance of <code>FreeAlgebra</code> we can define an adjunction in the same way, but for
    the class <code>MAlg</code>.

    So we end up with the following picture:
    <div class="diagram">
	<img src="/images/m-algebra-cats.svg" width="400px" />
    </div>

    There is also a comparison functor which fills the diagram at the top.  It
    is useally called <code>k</code> and it takes an object in <code>Alg</code>
    (which is the category of monoids in our case).  <code>k</code> can be defined as follows:
<pre class="haskell"><code>k :: Monoid  m
  => Proxy a
  -> (m a -> a)
k _ = foldFree
</code></pre>
    At the end we have a commutative diagram
    <div class="diagram">
	<img src="/images/m-algebra-cats-k.svg" width="400px" />
    </div>
    <h2>Monadicity</h2>
    <p>
	A right adjoin functor $\mathrm{U}$ is called monadic iff the
	comparison functor is an equivalence of categories.  This means that
	the two categories <code>Alg</code> and <code>MAlg</code> have exactly
	the same categorical properties.  It turns out that all algebraic
	theories which have free algebras (equivalently equational theories)
	are monadic.  This includes the categories of semigroups, monoids,
	groups, etc are all monadic, but also the categories of functors,
	applicative functors and monads on <code>Hask</code> are monadic too.

	From technical point of view, maybe the most important thing is that
	the free monad encodes algebraic operations that the intial category
	was using.  So in out example, we should be able to define
	<code><></code> and <code>mempty</code> only using the list monad.  And it's quite trivial:

<pre class="haskell"><code>-- |
-- @'mempty'@ deduced from @FreeAlg []@ @MAlg@ instance.
k_inv_monoid_mempty :: MAlg [] a => a
k_inv_monoid_mempty = foldFreeAlg (FreeAlg [])

-- |
-- @'mappend'@ deduced from @FreeAlg []@ @MAlg@ instance.
k_inv_monoid_mappend :: MAlg [] a => a -> a -> a
k_inv_monoid_mappend a b = foldFreeAlg (FreeAlg [a, b])

-- |
-- @'<>'@ deduced from @FreeAlg NonEmpty@ @MAAlg@ instance.
k_inv_semigroup_append :: MAlg NonEmpty a => a -> a -> a
k_inv_semigroup_append a b = foldFreeAlg (FreeAlg (a :| [b]))

k_inv_pointed :: MAlg Maybe a => a
k_inv_pointed = foldFreeAlg (FreeAlg Nothing)

-- |
-- @'invert'@ deduced from @FreeAlg FreeGroup@ @MAlg@ instance.
k_inv_group_invert :: (MAlg FreeGroup a, Eq a) => a -> a
k_inv_group_invert a = foldFreeAlg (FreeAlg (FreeGroup.fromList [Left a]))

-- |
-- @'act'@ deduced from @FreeAlg FreeMSet@ @MAlg@ instance.
k_inv_act :: (MAlg (FreeMSet m) a, Monoid m) => m -> a -> a
k_inv_act m a = foldFreeAlg $ FreeAlg $ FreeMSet (m, a)
</code></pre>
    </p>

    <h2>Final remarks</h2>
    I made some simplifications in the code posted here, so it will not work
    without some small changes. A working example is <a
    href="https://github.com/coot/free-algebras/tree/master/example/src/Data/Algebra/Free/Monadicity.hs">here</a>
{% endblock %}
