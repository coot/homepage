{-|
Module      : Data.Algebra.Free
Description : Univeral Algebra approach to free algebras by examples https://marcinszamotulski.me/posts/free-monads.html.
Author      : Marcin Szamotulski, 2018
Copyright   : (c) Marcin Szamotulski, 2018
License     : MPL 2.0 (https://www.mozilla.org/en-US/MPL/2.0/)
Stability   : Experimental

This is a @GHC@ implementation of Universal Algebra approach to free algebras.
For a theoretical introduction to Universal Algebra and free algebras please
read [\"From Free Algebras to Free Monads\"](https://marcinszamotulski.me/posts/free-monads.html).
 -}
{-# OPTIONS_HADDOCK show-extensions     #-}

{-# LANGUAGE ConstraintKinds            #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DeriveFunctor              #-}
{-# LANGUAGE ExplicitForAll             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE FunctionalDependencies     #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE InstanceSigs               #-}
{-# LANGUAGE KindSignatures             #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE PolyKinds                  #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE UndecidableInstances       #-}

module Data.Algebra.Free where

import Prelude hiding (Monoid, Semigroup, mempty, (<>))

import           Control.Monad (ap, join)
import           Control.Monad.Free (Free)
import qualified Control.Monad.Free as Free
import           Data.Constraint (Dict (..))
import           Data.Functor.Classes (Eq1 (..), Show1 (..), showsPrec1)
import           Data.Functor.Const (Const (..))
import           Data.Functor.Contravariant (Op (..))
import           Data.Functor.Coyoneda (Coyoneda (..), liftCoyoneda)
import           Data.Functor.Identity (Identity (..))
import           Data.Functor.Day (Day (..))
import qualified Data.Functor.Day as Day
import qualified Data.List as List
import           Data.List.NonEmpty (NonEmpty (..))
import           Data.Proxy (Proxy (..))
import           GHC.Exts (Constraint)

-- * Algebra type and free algebras

-- |
-- We will use this type class to define constrains of concrete algebras, e.g.
--
-- > type instance AlgebraType [a] m = Monoid m
-- > type instance AlgebraType FreeCommutativeMonoid m = (Monoid m, CommutativeSemigroup m)
type family AlgebraType (a :: k) (b :: l) :: Constraint

-- |
-- A free algebra of type @'AlgebraType'@.  A @'FreeAlgebra'@ constraint
-- proves that @'m'@ is a free algebra in the class of algebras of type
-- @'AlgebraType' m@ over the generators @'gen'@.
--
-- A lawful instance should imply @'AlgebraType' m (m a)@ for all @a@.
class FreeAlgebra (m :: * -> *)  where
    -- | Injective map that embeds generators of @m@.
    gen :: a -> m a
    -- | The freeness property.
    free :: forall d a .  AlgebraType m d
         => (a -> d)   -- ^ map generators of @m@ into @d@
         -> (m a -> d) -- ^ returns a homomorphism from @m@ to @d@

-- |
-- All types which satisfy @'FreeAlgebra'@ constraint are foldable.
foldFree
    :: ( FreeAlgebra m
       , AlgebraType m a
       )
    => m a
    -> a
foldFree = free id

-- |
-- The canonical quotient map from a free algebra of a wider class to a free
-- algebra of a narrower class, e.g. from free non-associative semigroup to
-- free associative semigroup, free monoid to free commutative monoid, etc.
--
-- > hoistFree . hoistFree == hoistFree
-- > mapFree f . hoistFree == hiostFree . mapFree f
hoistFree
    :: forall m n a .
       ( AlgebraType m (n a) -- the algebra @n a@ is of the same type as algebra @m@
       , FreeAlgebra m       -- @m@ is free generated by @a@
       , FreeAlgebra n       -- @n@ is free generated by @a@
       )
    => m a
    -> n a
hoistFree = free gen

-- |
-- All types which satisfy @'FreeAlgebra'@ constraint are functors.
-- The constraint @'AlgebraType' m (m b)@ is always satisfied.
mapFree :: forall m a b .
           ( FreeAlgebra m
           , AlgebraType m (m b)
           )
        => (a -> b)
        -> m a
        -> m b
mapFree f ma = free (gen . f) ma

-- |
-- @'FreeAlgebra'@ constraint imply monad.
joinFree :: ( FreeAlgebra m
            , AlgebraType m (m a)
            )
         => m (m a)
         -> m a
joinFree = foldFree

-- |
-- The monadic @'bind'@ operator.
bindFree :: ( FreeAlgebra m
            , AlgebraType m (m b)
            , AlgebraType m (m (m b))
            )
         => m a
         -> (a -> m b)
         -> m b
bindFree ma f = joinFree $ mapFree f ma

-- ** Non-Associative Semigroups

-- | Non-Associative (abbrev NA) semigroup bears `<>` method which is not
-- subject to any laws.
class NASemigroup a where
    -- associativity law is not assumed at this point
    (<>) :: a -> a -> a

-- |
-- Free non-associative semigroup generated by a type @a@.
data FreeNASemigroup a = Generator a | (FreeNASemigroup a) :*: (FreeNASemigroup a)
    deriving (Show, Eq, Ord)

-- |
-- Defines @'AlgebraType'@ of @'FreeNASemigroup' a@ to be @'NASemigroup'@.
type instance AlgebraType FreeNASemigroup n = NASemigroup n

-- |
-- @'FreeNASemigroup'@ is a free algebra.
instance FreeAlgebra FreeNASemigroup where
    gen = Generator
    free f (Generator a) = f a
    free f (a :*: b)     = free f a <> free f b

-- |
-- Non associative multiplication is just given by the @':*:'@ constructor.
instance NASemigroup (FreeNASemigroup a) where
    a <> b = a :*: b

instance Functor FreeNASemigroup where
    fmap = mapFree

instance Applicative FreeNASemigroup where
    pure  = gen
    (<*>) = ap

instance Monad FreeNASemigroup where
    return = gen
    (>>=)  = bindFree

foldNA :: NASemigroup a => FreeNASemigroup a -> a
foldNA = foldFree

newtype Conj = Conj { runConj :: Bool }
instance NASemigroup Conj where
    Conj True <> b = b
    _         <> _ = Conj False

newtype Disj = Disj { runDisj :: Bool }
instance NASemigroup Disj where
    Disj True <> _ = Disj True
    _         <> b = b

-- *** Examples
-- |
-- Non associative natural numbers:
--
-- > (), () :*: (), (() :*: ()) :*: (), () :*: (() :*: ()), ...
--
type FreeNASemigroup1 = FreeNASemigroup ()

-- | Free non associative semigroup with two generators.
type FreeNASemigroup2 = FreeNASemigroup (Sum ('Succ ('Succ 'Zero)) ())

-- ** Associative Semigroups

-- |
-- Class for associative semigroups, for which:
--
-- >  (a <> b) <> c = a <> (b <> c)
--
class NASemigroup m => Semigroup m

instance Semigroup Nat
instance Semigroup Conj
instance Semigroup Disj
instance Semigroup a => Semigroup (Prod n a)

-- |
-- Free semigroup
newtype FreeSemigroup a = FreeSemigroup { runFreeSemigroup :: NonEmpty a }
    deriving (Eq, Ord)

instance Show a => Show (FreeSemigroup a) where
    show (FreeSemigroup as) = "FreeSemigroup " ++ show as

type instance AlgebraType FreeSemigroup m = Semigroup m

instance NASemigroup (FreeSemigroup a) where
    FreeSemigroup (a :| as) <> FreeSemigroup (b :| bs)
        = FreeSemigroup $  a :| as ++ b : bs
instance Semigroup (FreeSemigroup a)
instance Functor FreeSemigroup where
    fmap = mapFree
instance Applicative FreeSemigroup where
    pure  = gen
    (<*>) = ap
instance Monad FreeSemigroup where
    return = gen
    (>>=)  = bindFree

-- |
-- Proof that @'FreeSemigroup' a@ is a free semigroup generated by @a@.
instance FreeAlgebra FreeSemigroup where
    gen a = FreeSemigroup $ a :| []
    -- @sconncat . fmap f@
    free f (FreeSemigroup (a :| [])) = f a
    free f (FreeSemigroup (a :| (a' : as')))
        = f a <> free f (FreeSemigroup $ a' :| as')

foldNonEmpty :: Semigroup a => FreeSemigroup a -> a
foldNonEmpty = foldFree

-- | Free (associative) semigroup with one generator, which is commutative.
type FreeSemigroup1 = FreeSemigroup ()
-- | Free (associative) semigroup with two generators, hence non commutative.
type FreeSemigroup2 = FreeSemigroup (Either () ())

-- |
-- This map is the canonical epimorphism from the free non-associative
-- semigroup to free associative semigroup.  It is uniquely determined on
-- generators.
--
-- >>> toAssociative $ Generator () :*: (Generator () :*: Generator ())
-- FreeSemigroup () :| [(),()]
-- >>> toAssociative $ (Generator () :*: Generator ()) :*: Generator ()
-- FreeSemigroup () :| [(),()]
--
-- >>> toAssociative (mapFree (\_ -> 0) (Generator () :*: Generator ()))
-- FreeSemigroup 0 :| [0]
-- >>> mapFree (\_ -> 0) $ toAssociative (Generator () :*: Generator ())
-- FreeSemigroup 0 :| [0]
toAssociative :: forall a. FreeNASemigroup a -> FreeSemigroup a
toAssociative = hoistFree

-- ** Pointed Algebras

-- |
-- A class for pointed types, aka pointed sets, i.e. types with a distinguished
-- term.  This is one of the simple algebras. Homomorphism of pointed algebras
-- are required to preserve the distinguished element.
class Pointed m where
    mempty :: m -- ^ distinguished term

instance Pointed () where
    mempty = ()

-- | @'Zero'@ is the distinguished term of type @'Nat'@.
instance Pointed Nat where
    mempty = Zero

-- |
-- Every free algebra generated by the unit type @'()'@ has the distinguished
-- element @gen () :: 'Pointed'@.
instance {-# overlappable #-} FreeAlgebra m => Pointed (m ()) where
    mempty = gen ()

instance Pointed (Maybe a) where
    mempty = Nothing

instance Pointed b => Pointed (Either a b) where
    mempty = Right mempty

type instance AlgebraType Maybe p = Pointed p

-- |
-- @'Maybe' a@ is the free pointed algebra generated by @a@.
--
-- >>> mapFree @Maybe (+1) (Just 0)
-- Just 1
-- >>> joinFree @Maybe (Just (Nothing :: Maybe Int))
-- Nothing
-- >>> joinFree @Maybe (Just (Just 1))
-- Just 1
instance FreeAlgebra Maybe where
    gen = Just
    free f Nothing = mempty
    free f (Just a) = f a

-- | @'Generator' ()@ is the distinguished term of type @'FreeNASemigroup1'@.
instance Pointed FreeNASemigroup1 where
    mempty = Generator ()

-- ** Sums and Products
-- Arbitrary finite products; `GHC.TypeNats.+` is not an injective type family,
-- this is a problem for us, so let's define our own type level natural
-- numbers.

-- |
-- Type level natural numbers promoted with @DataKinds@.
data Nat = Zero | Succ Nat
    deriving (Show, Eq, Ord)

-- |
-- @'Nat'@ is a semigroup.
instance NASemigroup Nat where
    m <> Zero   = m
    m <> Succ n = Succ m <> n

-- |
-- n-fold products
data Prod (n :: Nat) a where
    Cons         :: a -> Prod n a -> Prod ('Succ n) a
    EmptyProduct :: Prod 'Zero a

deriving instance Show a => Show (Prod n a)
deriving instance Eq a => Eq (Prod n a)

p1 :: Prod ('Succ ('Succ ('Succ 'Zero))) [()]
p1 = Cons [()] (Cons [] (Cons [] EmptyProduct))

p2 :: Prod ('Succ ('Succ ('Succ 'Zero))) [()]
p2 = Cons [] (Cons [()] (Cons [] EmptyProduct))

p3 :: Prod ('Succ ('Succ ('Succ 'Zero))) [()]
p3 = Cons [] (Cons [] (Cons [()] EmptyProduct))

-- |
-- n-fold sum
data Sum (n :: Nat) a  where
    EmptySum :: Sum Zero a
    Add      :: Either (Sum n a) a -> Sum ('Succ n) a

deriving instance Show a => Show (Sum n a)
deriving instance Eq a => Eq (Sum n a)


s1 :: Sum ('Succ n) ()
s1 = Add (Right ())

s2 :: Sum ('Succ ('Succ n)) ()
s2 = Add (Left (Add (Right ())))

s3 :: Sum ('Succ ('Succ ('Succ n))) ()
s3 = Add (Left (Add (Left (Add (Right ())))))

-- | @'EmptyProduct'@ is the distinguished term of @'Prod' \''Zero' m@.
instance Pointed (Prod 'Zero m) where
    mempty = EmptyProduct

-- |
-- This is diagonal build recursively by solving constraints.
instance (Pointed m, Pointed (Prod n m)) => Pointed (Prod ('Succ n) m) where
    mempty = Cons mempty mempty

-- |
-- In Category Theory there is a unique morphism from a (disjoint) sum `a ∪ b`
-- to a product `a × b`.  This type class let us construct it inductively.
--
-- >>> toProduct @('Succ ('Succ 'Zero)) Just $ Add (Right 0)
-- Cons (Just 0) (Cons Nothing EmptyProduct) 
-- >>> toProduct @('Succ ('Succ 'Zero)) Just $ Add (Left (Add $ Right 0))
-- Cons Nothing (Cons (Just 0) EmptyProduct)
class ToProduct (n :: Nat) m a b where
    toProduct :: (a -> b) -- ^ how to transform coeffcients
              -> m n a    -- ^ a sum type
              -> Prod n b -- ^ the resulting product

instance ToProduct 'Zero Sum a b where
    toProduct _ _ = EmptyProduct
instance ( Pointed m
         , Pointed (Prod n m)
         , ToProduct n Sum a m
         ) =>
         ToProduct ('Succ n) Sum a m where
    toProduct f (Add (Left s))  = Cons mempty (toProduct f s)
    toProduct f (Add (Right a)) = Cons (f a) mempty

-- |
-- Construct any @'Prod'@ with all values equal in CPS style.
diagonal :: Nat -> a -> (forall n. Prod n a -> r) -> r
diagonal Zero _ f     = f EmptyProduct
diagonal (Succ n) a f = diagonal n a (f . Cons a)

instance NASemigroup a => NASemigroup (Prod n a) where
    EmptyProduct <> EmptyProduct = EmptyProduct
    Cons a as <> Cons b bs       = Cons (a <> b) (as <> bs)

-- * Monoids
class (Semigroup m, Pointed m) => Monoid m

instance Monoid Nat

-- |
-- @'UndecidableInstances'@ is required here since the constraint is no
-- smaller than the instance head.
instance (Monoid m, Pointed (Prod n m)) => Monoid (Prod n m)

newtype FreeMonoid a = FreeMonoid { runFreeMonoid :: [a] }
    deriving (Eq, Ord)

instance Show a => Show (FreeMonoid a) where
    show (FreeMonoid as) = "FreeMonoid " ++ show as

type instance AlgebraType FreeMonoid m = Monoid m

instance NASemigroup (FreeMonoid a) where
    FreeMonoid as <> FreeMonoid bs
        = FreeMonoid $ as ++ bs
instance Semigroup (FreeMonoid a)

-- | An empty list @[]@ is the distinguished term of @'FreeMonoid'@.
instance Pointed (FreeMonoid a) where
    mempty = FreeMonoid []
instance Monoid (FreeMonoid a)

instance FreeAlgebra FreeMonoid where
    gen :: a -> FreeMonoid a
    gen a = FreeMonoid [a]

    free :: Monoid d
         => (a -> d)
         -> FreeMonoid a
         -> d
    free f (FreeMonoid [])       = mempty
    free f (FreeMonoid (a : as)) = f a <> free f (FreeMonoid as)

instance Functor FreeMonoid where
    fmap = mapFree

instance Applicative FreeMonoid where
    pure  = gen
    (<*>) = ap

instance Monad FreeMonoid where
    return = gen
    (>>=)  = bindFree

foldMonoid :: Monoid m => FreeMonoid m -> m
foldMonoid = foldFree

toMonoid :: FreeSemigroup a -> FreeMonoid a
toMonoid = hoistFree

-- |
-- The class of commutative semigroups.
--
-- > a <> b = b <> a
class Semigroup a => CommutativeSemigroup a

-- | It is isomorphic with @'Nat'@ (as an additive monoid) via
-- @'natToFreeMonoid1'@.
type FreeMonoid1 = FreeMonoid ()
instance CommutativeSemigroup FreeMonoid1

type FreeMonoid2 = FreeMonoid (Sum ('Succ ('Succ 'Zero)) ())
type FreeMonoid3 = FreeMonoid (Sum ('Succ ('Succ ('Succ 'Zero))) ())

f1 :: FreeMonoid3
f1 = FreeMonoid [s1]

f2 :: FreeMonoid3
f2 = FreeMonoid [s2]

f3 :: FreeMonoid3
f3 = FreeMonoid [s3]

-- *** Commutative monoids

-- **** Free commutative monoid
-- The free commutative monoid is (Prod n FreeMonoid1) (with @n@ generators).

type instance AlgebraType (Prod n FreeMonoid1) m =
    ( Monoid m
    , CommutativeSemigroup m
    )

type instance AlgebraType Nat m = ( Monoid m, CommutativeSemigroup m )

-- Note that @'Prod' n FreeMonoid1@ is the free commutative monoid over
-- a set of @n@-generators @Sum n ()@ (in the class of commutative monoids).
-- This is not expressible by @'FreeAlgebra'@ constraint, because we'd need to
-- have a map @a -> Sum n ()@ for possibly infinite values of @n@.  That maybe
-- possible with GHC generics.

-- * Higher Kinded Algebras

-- |
-- The constraint that will be imposed on the generator type of kind (* -> *).
type family AlgebraType1 (m :: k) (b :: * -> *) :: Constraint

-- |
-- Higher kinded version of @'FreeAlgebra'@.  Instances includes free functors,
-- free applicative functors and free monads.
--
class FreeAlgebra1 (m :: (* -> *) -> * -> *) where
    -- | Natural transformation that embeds generators into @m@.
    gen1 :: AlgebraType1 m f => f a -> m f a

    -- | The freeness property.
    --
    -- Note that @'free1'@  will allow to build @'mapFree'@ (and thus
    -- @'joinFree'@), only because we provide a way to change the
    -- type inside @d@ from @a@ to @b@.
    free1 :: forall (d :: * -> *) f a b .
             ( AlgebraType m d
             , AlgebraType1 m f
             )
          => (forall x. f x -> d x)
          -- ^ natural transformation which embeds generators of @m@ into @d@
          -> (a -> b)
          -> (m f a -> d b)
          -- ^ a homomorphism from @m@ to @d@

-- |
-- @'FreeAlgebra1' m@ implies that @m f@ is a foldable:
foldFree1 :: ( FreeAlgebra1 m
             , AlgebraType m f
             , AlgebraType1 m f
             )
          => m f a -- ^
          -> f a
foldFree1 = free1 id id

-- |
-- This is Functor instance for @m@ when considered as en endofuctor of some
-- subcategory of @* -> *@ (e.g. endofunctors of _Hask_).
natFree1 :: forall m f g a .
            ( FreeAlgebra1 m
            , AlgebraType m (m g)
            , AlgebraType1 m f
            , AlgebraType1 m g
            )
         => (forall x. f x -> g x) -- ^ a natural transformation @f ~> g@
         -> m f a
         -> m g a
natFree1 nat mfa = free1 (gen1 . nat) id mfa

-- |
-- Analogous to @'hoistFree'@
--
-- > hoistFree1 . hoistFree1 = hoistFree1
hoistFree1
    :: forall m n f a .
       ( AlgebraType m (n f)
       , AlgebraType1 m f
       , AlgebraType1 n f
       , FreeAlgebra1 m
       , FreeAlgebra1 n
       )
    => m f a -- ^
    -> n f a
hoistFree1 = free1 gen1 id

-- |
-- @'FreeAlgegra1' m@ implies that @m f@ is a functor.
mapFree1 :: forall m f a b .
            ( FreeAlgebra1 m
            , AlgebraType m (m f)
            , AlgebraType1 m f
            )
         => (a -> b) -- ^
         -> m f a
         -> m f b
mapFree1 f mfa = free1 gen1 f mfa

-- |
-- @'joinFree1'@ makes @m@ a monad in some subcatgory of types of kind @* -> *@
-- (usually the end-functor category of @Hask@).
joinFree1 :: forall m f a .
             ( FreeAlgebra1 m
             , AlgebraType m (m f)
             , AlgebraType1 m (m f)
             )
          => m (m f) a -- ^
          -> m f a
joinFree1 = foldFree1

-- |
-- Bind operator for the @'joinFree1'@ monad
bindFree1 :: forall m f g a b .
             ( FreeAlgebra1 m
             , AlgebraType m (m g)
             , AlgebraType m (m (m g))
             , AlgebraType1 m (m g)
             , AlgebraType1 m f
             )
          => m f a
          -> (forall x . f x -> m g x) -- ^ natural transformation @f ~> m g@
          -> m g a
bindFree1 mfa nat = joinFree1 $ natFree1 nat mfa

assoc1 :: forall m f a .
      ( FreeAlgebra1 m
      , AlgebraType m f
      , AlgebraType m (m (m f))
      , AlgebraType1 m f
      , AlgebraType1 m (m f)
      )
   => m f (m f a)
   -> m (m f) (f a)
assoc1 mfmfa = free1 f g mfmfa
    where
        f :: forall x. f x -> m (m f) x
        f = natFree1 gen1 . gen1

        g :: m f a -> f a
        g = foldFree1

-- ** @'Functor1'@ and @'Monad1'@ classes

-- |
-- Higher order functor, e.g. functor on a (sub)category of *endofuncors*.
-- The usual functor laws::
-- 
-- @ 'fmap1' id = id @
--
-- @ 'fmap1' g . fmap1 f = 'fmap1' (f . g) @
class Functor1 (m :: (* -> *) -> * -> *) where
    type FunctorType1 m (f :: * -> *) :: Constraint
    fmap1 :: ( FunctorType1 m f
             , FunctorType1 m g
             )
          => (forall x. f x -> g x)
          -- ^
          -- note that by rank n types, one has not access to @x@, you are
          -- supposed to change the functor, e.g. 
          -- @ Just . runIdentity :: forall x . Identity x -> Maybe x @
          ->  m f a -> m g a

-- |
-- Higher order monad, e.g. monad in a (sub)category of _endofunctors_.
-- The usaual monad laws apply:
--
-- @ 'return1' fa '>>=:' f = f fa @
--
-- @ mfa '>>=:' 'return1'  = mfa @
--
-- @ mfa '>>=:' (\\ fa -> k fa '>>=:' h) = (mfa '>>=: k) '>>=:' h @
class Functor1 m => Monad1 (m :: (* -> *) -> * -> *) where
    return1 :: FunctorType1 m f => f a -> m f a
    (>>=:) :: ( FunctorType1 m f
             , FunctorType1 m g
             )
           => m f a
           -> (forall x . f x -> m g x)
           -> m g a

-- ** Coyoneda
--
-- $coyoneda
--
-- @
--  data Coyoneda f a = Coyoneda (b -> a) -> f b
-- @
--
-- It is the free construction for a functor.

-- |
-- Algebra type for a functor.
type instance AlgebraType  Coyoneda g = Functor g
type instance AlgebraType1 Coyoneda g = ()

-- |
-- Proof that @'Coyoneda' f@ is a free functor.
--
-- It satisfies:
--
-- > free1 id == lowerCoyoneda
--
-- >>> :{
--     let a = gen1 @Coyoneda (Identity 'a')
--     in free1 @Coyoneda @Identity id id a
-- >>> :}
-- Identity 'a'
--
-- >>> :{
--     let a = gen1 @Coyoneda (Op (const 0))
--     in free1 @Coyoneda @(Const Integer) (\(Op fn) -> Const $ fn undefined) id a
-- >>> :}
-- Const 0
--
-- >>> gen1 (Identity 'a') == Coyoneda id (Identity 'a')
-- True
instance FreeAlgebra1 Coyoneda where
    gen1 :: f a -> Coyoneda f a
    gen1 = liftCoyoneda

    free1 :: Functor g
          => (forall x. f x -> g x)
          -> (a -> b)
          -> Coyoneda f a
          -> g b
    free1 nat f (Coyoneda ba fx) = fmap f ba <$> nat fx

foldCoyoneda :: Functor f => Coyoneda f a -> f a
foldCoyoneda = foldFree1

instance Functor1 Coyoneda where
    type FunctorType1 Coyoneda f = ()
    fmap1 = natFree1

instance Monad1 Coyoneda where
    return1 = gen1
    (>>=:)  = bindFree1

-- ** Free applicative functor
--
-- Free applicative functor.  See [Free Applicative
-- Functors](https://arxiv.org/pdf/1403.0749.pdf) by
-- P.Capriotti and A.Kaposi.
data FreeA f a where
    Pure :: a -> FreeA f a
    FreeA :: f (x -> a) -> FreeA f x -> FreeA f a

data FreeAL f a where
    PureL  :: a -> FreeAL f a
    FreeAL :: f (x -> a) -> f x -> FreeAL f a

instance Functor f => Functor (FreeAL f) where
    fmap f (PureL a) = PureL (f a)
    fmap f (FreeAL fxa fx) = FreeAL (fmap f <$> fxa) fx

-- |
-- A smart constructor of @'FreeA'@. (and an isomorphism).
toFreeA :: forall f a. Functor f => FreeAL f a -> FreeA f a
toFreeA (PureL a) = Pure a
toFreeA (FreeAL fxa fx) = FreeA fxaa ff
    where
        ff = FreeA (const <$> fxa) (Pure fxa)
        fxaa = flip ($) <$> fx

instance Functor f => Functor (FreeA f) where
    fmap f (Pure a)          = Pure (f a)
    fmap fab (FreeA fxa ffx) = FreeA (fmap fab <$> fxa) ffx

instance Functor f => Applicative (FreeA f) where
    pure = Pure

    Pure fab      <*> fa = fab <$> fa
    FreeA fxab fx <*> fa = FreeA (fmap uncurry fxab) ((,) <$> fx <*> fa)

-- |
-- Algebra type for an applicative functor.
type instance AlgebraType  FreeA g = Applicative g
type instance AlgebraType1 FreeA g = Functor g

-- |
-- A proof that @'FreeA'@ is the free applicative monad.
--
-- >>> foldFree1 (gen1 @FreeA (Identity 'a'))
-- Identity 'a'
instance FreeAlgebra1 FreeA where
    gen1 :: Functor f => f a -> FreeA f a
    gen1 fa = FreeA (const <$> fa) (Pure fa)

    free1 :: forall (d :: * -> *) f a b .
             ( Functor f
             , Applicative d
             )
          => (forall x. f x -> d x)
          -> (a -> b)
          -> (FreeA f a -> d b)
    free1 _   f (Pure a) = pure $ f a
    free1 nat f (FreeA fxa fx) = fmap f $ nat fxa <*> free1 nat id fx

instance Functor1 FreeA where
    type FunctorType1 FreeA f = Functor f
    fmap1 = natFree1

instance Monad1 FreeA where
    return1 = gen1
    (>>=:)  = bindFree1

-- |
-- >>> foldFreeA (FreeA (Identity (+1)) (Pure 0))
-- Identity 1
foldFreeA :: Applicative f => FreeA f a -> f a
foldFreeA = foldFree1

coyonedaToFreeA :: forall f a . Functor f => Coyoneda f a -> FreeA f a
coyonedaToFreeA = hoistFree1

-- ** Day convolution
--
-- $dayConvolution
--
-- @
-- data Day f g a = Day (f b) (g c) (b -> c -> a)
-- @
--
-- Note that for @'Day' f g@ to be an applicative functor it is not enough that
-- @f@ and @g@ are functors, one needs to assume that both are applicative.
-- Hence @'Day' f f@ is not a candidate for a free applicative functor
-- generated by a functor @f@.  Nevertheless it bears @'FreeAlgebra1'@
-- property whenever @f@ is applicative functor.

-- |
-- Newtype wrapper around @'Day' f f a@.
newtype DayF f a = DayF { runDayF :: Day f f a }
    deriving (Functor, Applicative)

-- |
-- @'DayF' f@ has the same algebra type as @'FreeA' f@.
type instance AlgebraType  DayF g = Applicative g
type instance AlgebraType1 DayF g = Functor g

instance FreeAlgebra1 DayF where
    gen1 :: Functor f => f a -> DayF f a
    gen1 fa = DayF $ Day fa fa (\a _ -> a)

    free1 :: ( Functor f
             , Applicative d
             )
          => (forall x. f x -> d x)
          -> (a -> b)
          -> DayF f a
          -> d b
    free1 nat f (DayF day) = fmap f $ Day.dap . Day.trans2 nat . Day.trans1 nat $ day

instance Functor1 DayF where
    type FunctorType1 DayF f = Applicative f
    fmap1 = natFree1

instance Monad1 DayF where
    return1 = gen1
    (>>=:)  = bindFree1

-- |
-- Note that this morphism requires @f@ to be @'Applicative'@ rather than just
-- a @'Functor'@, like @'coyonedaToFreeA'@.
coyonedaToDay :: forall f a . Applicative f => Coyoneda f a -> DayF f a
coyonedaToDay = hoistFree1

-- |
-- An ismorphism with inverse @'dayToFreeA'@;
-- 
-- > freeAToDay . dayToFreeA = id
-- > dayToFreeA . freeAToDay = id
--
-- >>> Day.dap $ runDayF $ freeAToDay . dayToFreeA $ DayF $ Day Nothing (Just 1) (+)
-- Nothing
-- >>> Day.dap $ runDayF $ freeAToDay . dayToFreeA $ DayF $ Day (Just 1) (Just 1) (+)
-- Just 2
-- >>> foldFreeA $ dayToFreeA . freeAToDay $ FreeA Nothing (Pure 1)
-- Nothing
-- >>> foldFreeA $ dayToFreeA . freeAToDay $ FreeA (Just (+1)) (Pure 1)
-- Just 2
freeAToDay :: forall f a . Applicative f => FreeA f a -> DayF f a
freeAToDay = hoistFree1

-- |
-- Left inverse of @'freeAToDay'@ (split monomorhism).
dayToFreeA :: forall f a . Applicative f => DayF f a -> FreeA f a
dayToFreeA = hoistFree1

-- ** Free monads
--
-- $freeMonad
--
-- @
-- data Free f a
--    = Return a
--    | Free (f Free f a)
-- @

-- |
-- Algebra type for a monad.
type instance AlgebraType  Free m = Monad m
type instance AlgebraType1 Free f = Functor f

-- |
-- A proof that @'Free' f@ is a free monad.
--
-- > free1 id == Free.retract
--
-- >>> foldFree1 (gen1 @Free (Identity 1))
-- Identity 1
instance FreeAlgebra1 Free where
    gen1 :: Functor f => f a -> Free f a
    gen1 = Free.liftF

    free1 :: (Functor f, Monad d)
          => (forall x. f x -> d x)
          -> (a -> b)
          -> Free f a
          -> d b
    free1 nat f ff = fmap f $ Free.foldFree nat ff

instance Functor1 Free where
    type FunctorType1 Free f = Functor f
    fmap1 = natFree1

-- |
-- >>> Free.Free (Identity (Free.Pure 'a')) >>=: return1
-- Free (Identity (Pure 'a'))
-- >>> return1 (Identity 'a') >>=: Free.liftF @Identity @(Free Identity)
-- Free (Identity (Pure 'a'))
-- >>> Free.Free (Identity (Free.Pure 0)) >>=: (\(Identity a) -> return1 (Just a)  >>=: (\fb -> return1 (maybe (Left ()) Right fb)))
-- Free (Right (Pure 0))
-- >>> Free.Free (Identity (Free.Pure 0)) >>=: (return1 . Just . runIdentity) >>=: (return1 . maybe (Left ()) Right)
-- Free (Right (Pure 0))
instance Monad1 Free where
    return1 :: forall f x
             . Functor f
            => f x -- ^
            -> Free f x
    return1 = gen1

    (>>=:) :: forall f g a
           .  ( Functor f
              , Functor g
              )
           => Free f a -- ^
           -> (forall x . f x -> Free g x)
           -> Free g a
    (>>=:)  = bindFree1

foldFree_ :: Monad m => Free m a -> m a
foldFree_ = foldFree1

freeAToFree :: forall f a . Functor f => FreeA f a -> Free f a
freeAToFree = hoistFree1

-- ** Freer monads
--
-- $freerMonads

-- |
-- @'Freer'@ monad is a composition of @'Free'@ and @'Coyoneda'@.  We only
-- require that the generators @f@ are of kind @* -> *@ but not necessarily
-- a functor.
newtype Freer f a = Freer { runFreer :: Free (Coyoneda f) a }
    deriving (Functor, Applicative, Monad)

type instance AlgebraType  Freer m = Monad m
type instance AlgebraType1 Freer f = ()

-- |
-- @'Freer'@ monad is a @'FreeAlgebra1'@ over @f :: * -> *@ which not
-- necessarilly is a functor.
instance FreeAlgebra1 Freer where
    gen1 fa = Freer $ gen1 $ Coyoneda id fa
    free1 :: forall f d a b. Monad d
          => (forall x. f x -> d x)
          -> (a -> b)
          -> Freer f a
          -> d b
    free1 _ f (Freer (Free.Pure a)) = return $ f a
    free1 nat f (Freer (Free.Free (Coyoneda bfca fb))) = do
        b <- nat fb
        free1 nat f $ Freer $ bfca b

instance Functor1 Freer where
    type FunctorType1 Freer f = ()
    fmap1 = natFree1

instance Monad1 Freer where
    return1 = gen1
    (>>=:)  = bindFree1

foldFreer :: Monad m => Freer m a -> m a
foldFreer = foldFree1

coyonedaToFreer :: forall f a . Coyoneda f a -> Freer f a
coyonedaToFreer = hoistFree1

-- |
-- Iso with inverse @'freeToFree'@, since @'Coyoneda' f@ is isomorphic to @f@
-- when @f@ is a functor.
freeToFreer :: forall f a . Functor f => Free f a -> Freer f a
freeToFreer = hoistFree1

freerToFree :: forall f a . Functor f => Freer f a -> Free f a
freerToFree = hoistFree1

-- * f-algebras

-- |
-- A uniform way of defining algebras.  For example the `Algebra (FreeMonoid m)
-- m` instance is a proof that a monoid is an `FreeMonoid-algebra` (in the
-- sense of f-algebras).  Inverse is also true, by monadicity of category of
-- monoids.  Hence having a `fold :: [m] -> m` which respects the laws of
-- `FreeMonoid-algebras` is equivalent to having a monoid.
--
class FAlgebra f a where
    -- |
    -- Fold should satisfy two axioms
    --
    -- * unitality
    -- 
    -- @
    --  gen . fold = id
    -- @
    --
    -- * associativity
    --
    -- @
    --                  mapFree fold
    --         f (f a) --------------> f a
    -- joinFree   |                    | fold
    --            v                    v
    --          f a  ----------------> a
    --                    fold
    -- @
    --
    -- f-algebras form a category with morphisms from @f a -> a@ to @f b -> b@
    -- a map @h :: a -> b@ such that
    --
    -- @
    --          f a -> a
    --  fmap h   |     | f
    --           v     v
    --          f b -> b
    -- @
    --
    -- For all equational theories the category of f-algebras is equivalent to
    -- the cateogory of algebras for whcih @f@ is free, e.g. category of
    -- monoids is equivalent to the category @'FreeMonoid'@-algebras, the
    -- category of semigroups is equivalent to the category of
    -- @'FreeSemigroup'@-algebras.
    fold :: (FreeAlgebra f, AlgebraType f a) => f a -> a

instance NASemigroup a => FAlgebra FreeNASemigroup a where
    fold :: NASemigroup a => FreeNASemigroup a -> a
    fold = foldFree

instance Semigroup a => FAlgebra FreeSemigroup a where
    fold :: Semigroup a => FreeSemigroup a -> a
    fold = foldFree

instance Monoid m => FAlgebra FreeMonoid m where
    fold :: Monoid m => FreeMonoid m -> m
    fold = foldFree

-- $monadicity
-- You can get back the algebra operations from @'fold'@:

mappend' :: Monoid m => m -> m -> m
mappend' a b = fold (FreeMonoid [a, b])

mempty' :: Monoid m => m
mempty' = fold (FreeMonoid [])


-- * Higher Kinded F-Algebras

class FAlgebra1 (m :: (* -> *) -> * -> *) (f :: * -> *) where
    fold1 :: FreeAlgebra1 m => m f a -> f a
    -- @fold1@ should satisfy two axioms
    --
    -- * unitality
    -- 
    -- @
    --  gen1 . fold1 = id
    -- @
    --
    -- * associativity
    --
    -- @
    --                 mapFree1 fold1
    --      m (m f) a  --------------> m f a
    -- joinFree1  |                      | fold1
    --            v                      v
    --         m f a  ----------------> f a
    --                     fold1
    -- @

instance Functor f => FAlgebra1 Coyoneda f where
    fold1 = foldFree1

instance Applicative f => FAlgebra1 FreeA f where
    fold1 = foldFree1

instance Monad m => FAlgebra1 Free m where
    fold1 = foldFree1

instance Monad m => FAlgebra1 Freer m where
    fold1 = foldFree1

instance Applicative f => FAlgebra1 DayF f where
    fold1 = foldFree1

-- $monadicity1
-- You can get back the operations of a given algebra from @'fold1'@, e.g. for
-- a monad, you can reconstruct both @'return'@ and @'join'@ (or @'bind'@):

return' :: FAlgebra1 Free m => a -> m a
return' = fold1 . Free.Pure

-- |
-- We can use the functor instance to construct @'join''@ since it is
-- a constraint that is brought by @'FreeAlgebra1' Free m@, we can use this
-- constrain since it is a requirement in @'FreeAlgebra1' Free@ instance.
join'
    :: forall m a
     . ( FAlgebra1 Free m
       , AlgebraType1 Free m
       )
    => m (m a)
    -> m a
join' mma = fold1 $ Free.Free fma
    where
        fma :: m (Free m a)
        fma = Free.Free . fmap Free.Pure <$> mma

bind'
    :: forall m a b
     . ( FAlgebra1 Free m
       , AlgebraType1 Free m
       )
    => m a
    -> (a -> m b)
    -> m b
bind' ma f = join' $ f <$> ma

-- $monadicityApplicative
-- For applicative functor you can get define the @'pure'@ and @'ap'@

pure' :: FAlgebra1 FreeA f => a -> f a
pure' = fold1 . Pure

ap'
    :: forall f a b
     . ( FAlgebra1 FreeA f
       , AlgebraType1 FreeA f
       )
    => f (a -> b)
    -> f a
    -> f b
ap' fab fa = fold1 (toFreeA (FreeAL fab fa))

-- @monadicityCoyoneda
-- The same holds for @'Coyoneda'@, one can define @'fmap'@ just using @'fold1'@

fmap'
    :: forall f a b
     . (FAlgebra1 Coyoneda f)
    => (a -> b)
    -> f a
    -> f b
fmap' ab fa = fold1 (Coyoneda ab fa)

-- $finalNote
--
-- As you can see all the operations, like @\<$\>@, @\<*\>@, @join@ or @'>>='@
-- are just encoded in the data structures!  This is what the free structures
-- all about. If you read the associated 
-- [post](https://marcinszamotulski.me/posts/free-monads.html) then you should
-- connected this with the fact that free algebras are build out of terms, i.e.
-- the operations.
