<!DOCTYPE html lang="en">
    <head id="head">
	<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<title>Marcin Szamotulski Homepage</title>
<meta name="description" content="I am a mathematician (PhD) and a software engineer delivering solutions using JavaScript, Haskell, Purescript and Python." /> 
<meta name="author" content="Marcin Szamotulski" />
<meta name="keywords" content="JavaScript React Angular Python Haskell PureScript programming  web applications PWA" />
<meta prefix="og: http://ogp.me/ns#" property="og:title" content="Marcin Szamotulski - software engineer" />
<meta prefix="og: http://ogp.me/ns#" property="og:site_name" content="Marcin Szamotulski - software engineer" />
<meta prefix="og: http://ogp.me/ns#" property="og:description" content="I am a full-stack developer and a mathematician" />
<meta prefix="og: http://ogp.me/ns#" property="og:type" content="website" />
<meta prefix="og: http://ogp.me/ns#" property="og:url" content="http:/marcinszamotulski.me" />
<meta prefix="og: http://ogp.me/ns#" property="og:image" content="http://marcinszamotulski.me/images/marcinszamotulski-large.jpg" />
<meta property="fb:admins" content="100001888925907" />

<link rel="shortcut icon" type="image/png" href="/images/elf-fg-gray-no-background-250.png" />
<link rel="manifest"   href="/manifest.json" />
<link rel="stylesheet" href="/assets/style.css" />
<link rel="stylesheet" href="/assets/normalize.css" />
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" />
<link rel="stylesheet" href="/assets/print_style.css" media="print"/>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600" />

<script type="text/javascript" async src="/assets/html5shiv.js"></script>
<script type="text/javascript" async src="/assets/html5shiv-printshiv.js"></script>
<script type="text/javascript" src="/assets/index.js"></script>


        
        <meta name="twitter:card" content="photo" />
        <meta name="twitter:title" content="Mathematics and Programming Blog" />
        <meta name="twitter:description" content="Blog about reach intersection of mathematics and programming, explaining mathematical ideas behind programming languages concepts." />
        <meta name="twitter:creator" content="@me_coot" />
        <meta name="twitter:url" content="https://marcinszamotulski.me" />
        <meta name="twitter:site" content="@me_coot" />
        
        
        <meta name="twitter:image" content="https://marcinszamotulski.me/images/monad-associativity.png" />
        

	
	<script type="text/javascript" async
	    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
	<script type="text/x-mathjax-config">
	    MathJax.Hub.Config({
		tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
		TeX: {
		    extensions: ["AMSmath.js"]
		},
	    });
	</script>
	<link href="https://fonts.googleapis.com/css?family=Oxygen+Mono:300" rel="stylesheet"> 

	<!-- Matomo -->
	<script async type="text/javascript">
	  var _paq = _paq || [];
	  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
	  _paq.push(['trackPageView']);
	  _paq.push(['enableLinkTracking']);
	  (function() {
	    var u="//analitics.marcinszamotulski.me/";
	    _paq.push(['setTrackerUrl', u+'piwik.php']);
	    _paq.push(['setSiteId', '1']);
	    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
	    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
	  })();
	</script>
	<!-- End Matomo Code -->
    </head>
    <body>
	<div id="wrapper" class="wrapper post">
	    <header class='info-hdr'>
		
		<ul class="links">
		    <li class="home">
			<a href="/">Home</a>
		    </li>
		</ul>

	    </header>
	    <main>
		
<h1 id="typed-transitions-finite-state-machines-and-free-categories">Typed Transitions, Finite State Machines and Free Categories</h1>
<p>In this post we will explore <strong>finite state machines</strong> with typed transitions represented as finite directed graphs via <strong>free categories</strong>. You will also see how usefull is the <strong>Kleisli category</strong>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE KindSignatures #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE RankNTypes #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">{-# LANGUAGE TypeApplications #-}</span></a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Control.Category.FSM</span> <span class="kw">where</span></a></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Prelude</span> <span class="kw">hiding</span> (id, foldMap, (.))</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- ^ Note that we&#39;re imporing `id` and `.`</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">--   from `Control.Category`</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Control.Category</span> (<span class="dt">Category</span> (id, (.)), (&lt;&lt;&lt;))</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Control.Monad</span> ((&gt;=&gt;))</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span> (..), (&lt;|))</a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Data.Void</span> (<span class="dt">Void</span>)</a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Unsafe.Coerce</span> (unsafeCoerce)</a></code></pre></div>
<h2 id="free-category-construction">Free Category Construction</h2>
<p>A <em>free category</em> generated by a (directed) <em>graph</em> is formed by adding identity edges to each vertex and then taking the graph of all possible paths, i.e every path in this graph, becomes arrow in the generated category. The final step is to impose category theory laws: so that the added identity arrows satisfy the unit law. Path composition is always associative, so at least this we get for free. Composition of arrows is just composition of paths. Note that this construction correponds exactly to the construction of the <em>free monoid</em>: if you take a graph with a single vertex <code>*</code> and a bunch of edges from <code>*</code> to <code>*</code> then the <em>free monoid</em> generated by this set of edges is the same as the free category (every monoid can be seen as a category with a single object).</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cat</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="dt">Id</span><span class="ot"> ::</span> <span class="dt">Cat</span> f a a</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">    (:.:) ::</span> f b c <span class="ot">-&gt;</span> <span class="dt">Cat</span> f a b <span class="ot">-&gt;</span> <span class="dt">Cat</span> f a c</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Category</span> (<span class="dt">Cat</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    id <span class="fu">=</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="dt">Id</span> <span class="fu">.</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    (x <span class="fu">:.:</span> xs) <span class="fu">.</span> ys <span class="fu">=</span> x <span class="fu">:.:</span> (xs <span class="fu">.</span> ys)</a></code></pre></div>
<p>Let us check that the category theory laws holds. First let us observe that by recursive definition of <code>Cat</code>, every element has a form: <code>(f1 :.: (f2 :.: ( ... :.: Id)))</code>.</p>
<figure>
<img src="/images/free-cat-morphism.svg" alt="normal form of a morphism in Cat f" /><figcaption>normal form of a morphism in Cat f</figcaption>
</figure>
<p>The smallest <span class="math inline"><em>n</em></span> such that a morphism has this form we call the length of a morphism.</p>
<p>First unit law: <code>Id . x = x</code> holds by definition; to show <code>x . Id = x</code>, it’s enough to consider the case when x has length greater than 1:</p>
<pre><code>(x :.: xs) . Id
   = x :.: (xs . Id)
   -- by induction on the length of xs
   = x :.: xs</code></pre>
<p>Now let us prove associativity. The proof is also by induction on the length of the first element:</p>
<pre><code>((x :.: Id) . y) . z
  = (x :.: y) . z
  = (x :.: (y . z))
  = (x :.: (Id . (y . z))
  = (x :.: Id) . (y . z)</code></pre>
<p>And the induction step:</p>
<pre><code>((x :.: xs) . y) . z
  = (x :.: (xs . y)) . z
  =  x :.: ((xs . y) . z)
  -- by induction on the length of xs
  =  x :.: (xs . (y . z))
  =  (x :.: xs) . (y . z)</code></pre>
<p>As expected we have a lawful category <code>Cat f</code>.</p>
<p>For each <code>a</code> we have an embedding:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">endo ::</span> [f a a] <span class="ot">-&gt;</span> <span class="dt">Cat</span> f a a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">endo [] <span class="fu">=</span> <span class="dt">Id</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">endo (x <span class="fu">:</span> xs) <span class="fu">=</span> x <span class="fu">:.:</span> endo xs</a></code></pre></div>
<p>As all the free constructions, also free category has the lift operation which let you embed the generating graph into the free category generated by it. It is a generalisation of the singleton list</p>
<p><code>(: []) :: a -&gt; [a]</code></p>
<p>and at the same time <code>lift</code> for monad transformers.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">liftCat ::</span> f a b <span class="ot">-&gt;</span> <span class="dt">Cat</span> f a b</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">liftCat fab <span class="fu">=</span> fab <span class="fu">:.:</span> <span class="dt">Id</span></a></code></pre></div>
<p>Being a free category means that whenever you have a binatural transformation from <code>f :: * -&gt; * -&gt; *</code> to a category <code>Category g =&gt; g :: * -&gt; * -&gt; *</code> you can construct (in a unique way) a functor from <code>Cat f</code> to <code>g</code>. This is the spirit of free algebras. And indeed we can get a <code>foldMap</code> like map:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">foldFunCat</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    ::</span> forall f g a b <span class="fu">.</span> <span class="dt">Category</span> g</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="ot">=&gt;</span> (forall x y<span class="fu">.</span> f x y <span class="ot">-&gt;</span> g x y)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="co">-- ^ a map of graphs</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="ot">-&gt;</span> (<span class="dt">Cat</span> f a b <span class="ot">-&gt;</span> g a b)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    <span class="co">-- ^ a functor from &#39;Cat f&#39; to &#39;g&#39;</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">foldFunCat _ <span class="dt">Id</span> <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">foldFunCat fun (bc <span class="fu">:.:</span> ab)</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  <span class="fu">=</span> fun bc <span class="fu">&lt;&lt;&lt;</span> foldFunCat fun ab</a></code></pre></div>
<p>This is a free constructions in the sense I’ve been advocating for some time in a series of blog posts: <a href="https://marcinszamotulski.me/posts/free-monads.html">from free algebras to free monads</a>, <a href="https://marcinszamotulski.me/posts/monadicity.html">monadicity</a>, based on <a href="https://hackage.haskell.org/package/free-algebras">free-algebras</a> package (published on hackage).</p>
<h2 id="the-kleisli-category">The Kleisli Category</h2>
<p>in <code>Control.Arrow</code> there is the following construction, which is attributed to a Swiss category theorist <a href="https://www.genealogy.math.ndsu.nodak.edu/id.php?id=18361">Heinrich Kleisli</a>. It turns out that with any moand <code>m</code> one can associate a category where arrows are <code>a -&gt; m b</code> instead of <code>a -&gt; b</code>. Let us investigate this in detail, as this allows for many interesting interpretations.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Kleisli</span> m a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">   <span class="dt">Kleisli</span> {<span class="ot"> runKleisli ::</span> a <span class="ot">-&gt;</span> m b }</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Category</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  id                    <span class="fu">=</span> <span class="dt">Kleisli</span> return</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="dt">Kleisli</span> f <span class="fu">.</span> <span class="dt">Kleisli</span> g <span class="fu">=</span> <span class="dt">Kleisli</span> (g <span class="fu">&gt;=&gt;</span> f)</a></code></pre></div>
<p>The arrow</p>
<pre><code>(&gt;=&gt;) :: (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
(f &gt;=&gt; g) a = f a &gt;&gt;= g</code></pre>
<p>is called Kleisli composition (or if you prefer using <code>join</code>: <code>\f g a -&gt; join $ fmap g (f a)</code>). Monadic operations <code>return</code> and <code>&gt;&gt;=</code> carry the unitality laws:</p>
<pre><code>return &gt;&gt;= f = f
m &gt;&gt;= return = m</code></pre>
<p>They become even simpler when we re-write them using <code>&gt;=&gt;</code>:</p>
<pre><code>return &gt;=&gt; f = f
f &gt;=&gt; return = f</code></pre>
<p>This means that <code>Kleisli return</code> is indeed the identity arrow in <code>Kleisli m</code> category. It remain to show that the composition is associative, and this, as you can expect, can be derived from the monad associativity law:</p>
<pre><code>m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) = (m &gt;&gt;= k) &gt;&gt;= k)</code></pre>
<p>which using Kleisli composition, takes much simpler form (which conveys the reason for the name of this axiom):</p>
<pre><code>f &gt;=&gt; (g &gt;=&gt; h) = (f &gt;=&gt; g) &gt;=&gt; h</code></pre>
<p>Let us proove this:</p>
<pre><code>(f &gt;=&gt; (g &gt;=&gt; h)) a 
  = f a &gt;&gt;= (g &gt;=&gt; h)
  = f a &gt;&gt;= \b -&gt; g b &gt;&gt;= h)
  -- by monadic associativity law
  = (f a &gt;&gt;= g) &gt;&gt;= h
  = ((f &gt;=&gt; g) a) &gt;&gt;= h
  = ((f &gt;=&gt; g) &gt;=&gt; h) a</code></pre>
<p>The associativity of Kleisli composition <code>&gt;=&gt;</code> is exactly what we need to prove associativity of <code>Kleisli m</code> category, so we’re done! This is the one of rare cases when using point free style makes the presentation look much easier to read ;).</p>
<p>Also note that there is a functor from <code>(-&gt;)</code> category to <code>Kleisli m</code> given by</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">arr ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a b</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">arr f <span class="fu">=</span> <span class="dt">Kleisli</span> <span class="fu">$</span> return <span class="fu">.</span> f</a></code></pre></div>
<p>It is a part of the <code>Monad m =&gt; Arrow (Kleisli m)</code> instance in <code>Control.Arrow</code> module of the <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Arrow.html#t:Kleisli">base</a> package.</p>
<p>There is a worth noting sepcialization of <code>foldFunCat</code> to Kleisli category:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">foldFunKleisli</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">   ::</span> forall f m a b <span class="fu">.</span> <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">   <span class="ot">=&gt;</span> (forall x y<span class="fu">.</span> f x y <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m x y)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">   <span class="ot">-&gt;</span> (<span class="dt">Cat</span> f a b <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a b)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">foldFunKleisli <span class="fu">=</span> foldFunCat</a></code></pre></div>
<p>if you expand <code>Kleisli</code> newtype wrapper you will get the type</p>
<pre><code>foldFunKleisli&#39;
  :: (forall x y.  f x y -&gt; x -&gt; m y)
  -&gt; Cat f a b
  -&gt; a -&gt; m b</code></pre>
<p>A final observation that is useful, is that in any category the type <code>cat c =&gt; c v v</code> is a monoid with identity <code>id</code> and multiplication <code>(.)</code>. In <code>(-&gt;)</code> we have <code>Data.Monoid.Endo</code> newtype wrapper for that purpose, and it could be generalised:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Endo</span> c a <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="dt">Endo</span><span class="ot"> ::</span> <span class="dt">Category</span> c <span class="ot">=&gt;</span> c a a <span class="ot">-&gt;</span> <span class="dt">Endo</span> c a</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">Endo</span> c a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  <span class="dt">Endo</span> f <span class="fu">&lt;&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">&lt;&lt;&lt;</span> g)</a>
<a class="sourceLine" id="cb21-6" data-line-number="6"></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Category</span> c <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> c a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  mempty <span class="fu">=</span> <span class="dt">Endo</span> id</a></code></pre></div>
<p>This includes <code>Endo (Kleisli m) a ≅ a -&gt; m a</code> as an example (for a monad <code>m</code>). If you try to prove the associativity and unit laws for this monoid, you’ll discover that what you need is associativity and unit laws for monad.</p>
<h2 id="example-bifunctor-with-a-single-object">Example: bifunctor with a single object</h2>
<p>As an example let us consder a bifunctor with a single object:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Single</span> e v a b <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  <span class="dt">Single</span><span class="ot">      ::</span> e <span class="ot">-&gt;</span> <span class="dt">Single</span> e v v v</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="dt">VoidSingle</span><span class="ot">  ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> <span class="dt">Single</span> e v a b</a></code></pre></div>
<p>With <code>Single</code> you can only construct terms of type <code>Single e v v v</code>, any other term diverge. We need <code>VoidSingle</code> constructor to provide a <code>Category</code> type class instance.</p>
<p>In this case <code>endo</code> is an isomorphism with inverse (modulo <code>Single e v v v ≅ e</code>):</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">toList ::</span> <span class="dt">Cat</span> (<span class="dt">Single</span> e v) v v <span class="ot">-&gt;</span> [e]</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">toList <span class="dt">Id</span>                  <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">toList (<span class="dt">Single</span> e <span class="fu">:.:</span> es)    <span class="fu">=</span> e <span class="fu">:</span> toList es</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">toList (<span class="dt">VoidSingle</span> e <span class="fu">:.:</span> _) <span class="fu">=</span> undefined</a></code></pre></div>
<p>Whenever <code>e</code> is a <code>Monoid</code>, <code>Single e v</code> is a <code>Category</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">idSingle ::</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Single</span> e v v v</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">idSingle <span class="fu">=</span> <span class="dt">Single</span> mempty</a>
<a class="sourceLine" id="cb24-3" data-line-number="3"></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">composeSingle</a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="ot">   ::</span> <span class="dt">Monoid</span> e</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">   <span class="ot">=&gt;</span> <span class="dt">Single</span> e v b c</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">   <span class="ot">-&gt;</span> <span class="dt">Single</span> e v a b</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">   <span class="ot">-&gt;</span> <span class="dt">Single</span> e v a c</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">composeSingle (<span class="dt">Single</span> a)     (<span class="dt">Single</span> b)     <span class="fu">=</span> <span class="dt">Single</span> (a <span class="fu">&lt;&gt;</span> b)</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">composeSingle (<span class="dt">VoidSingle</span> _) _              <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">composeSingle _              (<span class="dt">VoidSingle</span> _) <span class="fu">=</span> undefined</a></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Category</span> (<span class="dt">Single</span> e v) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">  id ::</span> forall a <span class="fu">.</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Single</span> e v a a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  id <span class="fu">=</span> unsafeCoerce (idSingle <span class="fu">@</span>e)</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  (<span class="fu">.</span>) <span class="fu">=</span> composeSingle</a></code></pre></div>
<p>Furthemore, in this case the free category corresponds to free monoid; <code>Cat (Single e v)</code> is a single object category with</p>
<p><code>Cat (Single e v) v v ≅ [e]</code></p>
<p>the free monoid generated on type <code>Single e v v v ≅ e</code>.</p>
<figure>
<img src="/images/one-object-cat.svg" alt="category (Cat (Single e v)) with one object v" /><figcaption>category (Cat (Single e v)) with one object v</figcaption>
</figure>
<p>We will show now that <code>foldFunCat</code> in this case is nothing than a <code>foldMap</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">foldMap<span class="ot"> ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">foldMap _ [] <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">foldMap f (a <span class="fu">:</span> as) <span class="fu">=</span> f a <span class="fu">&lt;&gt;</span> foldMap f as</a></code></pre></div>
<p>First let us see how <code>foldFuncCat</code> specializes:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">_foldFunCat</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="ot">    ::</span> forall e f v a b <span class="fu">.</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">       <span class="dt">Monoid</span> e</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    <span class="ot">=&gt;</span> (forall x y <span class="fu">.</span> f x y <span class="ot">-&gt;</span> <span class="dt">Single</span> e v x y)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Cat</span> f a b</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Single</span> e v a b</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">_foldFunCat <span class="fu">=</span> foldFunCat</a></code></pre></div>
<p>now note that the only natural transformation <code>f x y -&gt; Single e v x y</code> that we can have are once that come from a map <code>g :: f v v -&gt; Single e v v v</code>. Hence <code>foldFunCat</code> reduces further to to</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">foldFunCat&#39;</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="ot">    ::</span> forall e f v<span class="fu">.</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">       <span class="dt">Monoid</span> e</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="ot">=&gt;</span> (f v v <span class="ot">-&gt;</span> <span class="dt">Single</span> e v v v)</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Cat</span> f v v</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Single</span> e v v v</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">foldFunCat&#39; f c <span class="fu">=</span> foldFunCat (unsafeCoerce f) c</a></code></pre></div>
<p>Assuming that <code>endo :: f v v -&gt; Cat f v v</code> is an isomorphism (which it is for a large class of bifunctors, e.g. <code>Single e v</code>), and since <code>Single e v v v ≅ e</code>, we have: <code>Cat (Single e v) v v ≅ [e]</code> (via <code>endo</code>) and <code>Single e v v v ≅ e</code> (given by <code>Single</code> constructor), so we end up with a map <code>(e -&gt; m) -&gt; [e] -&gt; m</code> which is the claimed <code>foldMap</code>. Finally, both <code>foldMap</code> and <code>foldFunCat</code> are defined using the same recursion pattern, hence they must be equal.</p>
<p>To recap what we have just show: <code>foldFunCat</code> for <code>f = Single e v</code> and <code>g = Monoid m =&gt; Single e v</code> is just <code>foldMap</code>. In this light we can view <code>foldFunCat</code> as a generalisation <code>foldMap</code>. There is also another way of coming to this conclusin via free objects (check out <a href="https://hackage.haskell.org/package/free-algebras">free-algebras package</a>.</p>
<h2 id="example-finite-state-machine">Example Finite State Machine</h2>
<p>For this post I picked the example of a state machine explored by Oscar Wickström in his short series about state machines: <a href="https://wickstrom.tech/finite-state-machines/2017/11/10/finite-state-machines-part-1-modeling-with-haskell.html">part 1</a> and <a href="https://wickstrom.tech/finite-state-machines/2017/11/19/finite-state-machines-part-2.html">part 2</a>. It is a simple state transition for an online shop. I slightly simplified it, by making the assumption that one can cancel at any stage (just for presentation purposes).</p>
<p>States (vertices of the FSM):</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">data</span> <span class="dt">NoItems</span>       <span class="fu">=</span> <span class="dt">NoItems</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">HasItems</span>   <span class="fu">=</span> <span class="dt">HasItems</span> (<span class="dt">NonEmpty</span> <span class="dt">CartItem</span>)</a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="kw">newtype</span> <span class="dt">NoCard</span>     <span class="fu">=</span> <span class="dt">NoCard</span> (<span class="dt">NonEmpty</span> <span class="dt">CartItem</span>)</a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="kw">data</span> <span class="dt">CardSelected</span>  <span class="fu">=</span> <span class="dt">CardSelected</span> <span class="dt">Card</span> (<span class="dt">NonEmpty</span> <span class="dt">CartItem</span>)</a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="kw">data</span> <span class="dt">CardConfirmed</span> <span class="fu">=</span> <span class="dt">CardConfirmed</span> <span class="dt">Card</span> (<span class="dt">NonEmpty</span> <span class="dt">CartItem</span>)</a>
<a class="sourceLine" id="cb29-6" data-line-number="6"><span class="kw">data</span> <span class="dt">OrderPlaced</span>   <span class="fu">=</span> <span class="dt">OrderPlaced</span></a></code></pre></div>
<p>The shop only sells unit objects (better than seling <code>Void</code> terms ;) )</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">type</span> <span class="dt">CartItem</span> <span class="fu">=</span> ()</a></code></pre></div>
<p>Accepted credit cards:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">String</span></a></code></pre></div>
<p>The FTM’s directed graph can be described by a type of kind <code>* -&gt; * -&gt; *</code>, where first type is the source of an arrow, the second type is its target. Directed graph lack composition, and we will fix this. In this example we take (after <a href="https://wickstrom.tech/finite-state-machines/2017/11/10/finite-state-machines-part-1-modeling-with-haskell.html">Oscar Wickström</a>, though here <code>Cancel</code> can abort at any stage rather than just during confirmation, just for simplicity):</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tr</span> s t <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="dt">SelectFirst</span><span class="ot"> ::</span> <span class="dt">CartItem</span> <span class="ot">-&gt;</span> <span class="dt">Tr</span> <span class="dt">NoItems</span> <span class="dt">HasItems</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="dt">Select</span><span class="ot">      ::</span> <span class="dt">CartItem</span> <span class="ot">-&gt;</span> <span class="dt">Tr</span> <span class="dt">HasItems</span> <span class="dt">HasItems</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    <span class="dt">SelectCard</span><span class="ot">  ::</span> <span class="dt">Card</span> <span class="ot">-&gt;</span> <span class="dt">Tr</span> <span class="dt">HasItems</span> <span class="dt">CardSelected</span></a>
<a class="sourceLine" id="cb32-5" data-line-number="5">    <span class="dt">Confirm</span><span class="ot">     ::</span> <span class="dt">Tr</span> <span class="dt">CardSelected</span> <span class="dt">CardConfirmed</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    <span class="dt">PlaceOrder</span><span class="ot">  ::</span> <span class="dt">Tr</span> <span class="dt">CardConfirmed</span> <span class="dt">OrderPlaced</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    <span class="dt">Cancel</span><span class="ot">      ::</span> <span class="dt">Tr</span> s <span class="dt">NoItems</span></a></code></pre></div>
<p>Category generated by the <code>Tr</code> graph.</p>
<figure>
<img src="/images/tr-graph.svg" alt="Tr graph" /><figcaption>Tr graph</figcaption>
</figure>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ShoppingCat</span> a b <span class="fu">=</span> <span class="dt">Cat</span> <span class="dt">Tr</span> a b</a></code></pre></div>
<p>As a graph <code>ShoppingCat</code> has the same vertices as <code>Tr</code>, but has more edges. Any path that you can follow in the <code>Tr</code> graph becomes a new edge in <code>ShoppingCat</code>, e.g. <code>SelectFirst</code> followed by <code>Select</code> is a new edge from <code>NoItems</code> to <code>HasItems</code>. Note that at this point we don’t have any interpretation of the arrows, we only modeled the shape of the category we want to have. This gives us freedom how to interpret this category in other categories using functors (not to confuse with <code>Functor</code> instances: these are endofunctors of <code>(-&gt;)</code>).</p>
<p>Interpretation of the <code>Tr</code> graph in the <code>(-&gt;)</code> category:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="ot">natPure ::</span> <span class="dt">Tr</span> a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">natPure (<span class="dt">SelectFirst</span> i) _            <span class="fu">=</span> <span class="dt">HasItems</span> (i <span class="fu">:|</span> [])</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">natPure (<span class="dt">Select</span> i) (<span class="dt">HasItems</span> is)     <span class="fu">=</span> <span class="dt">HasItems</span> (i <span class="fu">&lt;|</span> is)</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">natPure (<span class="dt">SelectCard</span> c) (<span class="dt">HasItems</span> is) <span class="fu">=</span> <span class="dt">CardSelected</span> c is</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">natPure <span class="dt">Confirm</span> (<span class="dt">CardSelected</span> c is)  <span class="fu">=</span> <span class="dt">CardConfirmed</span> c is</a>
<a class="sourceLine" id="cb34-6" data-line-number="6">natPure <span class="dt">PlaceOrder</span> _                 <span class="fu">=</span> <span class="dt">OrderPlaced</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7">natPure <span class="dt">Cancel</span> _                     <span class="fu">=</span> <span class="dt">NoItems</span></a></code></pre></div>
<p>Interpretation of <code>ShoppingCat</code> in <code>(-&gt;)</code> (a functor between two categories):</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">checkoutPure ::</span> <span class="dt">ShoppingCat</span> a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">checkoutPure <span class="fu">=</span> foldFunCat natPure</a></code></pre></div>
<p>But we can easily interpret in <code>ShoppingCat</code> in any Kleisli category, especially in <code>Klesli IO</code>. Here we lift just the pure interpretation, but equaly well you could do some <code>IO</code> here.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">checkoutM</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="ot">    ::</span> forall m a b <span class="fu">.</span> <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">ShoppingCat</span> a b</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a b</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">checkoutM <span class="fu">=</span> foldFunCat nat</a>
<a class="sourceLine" id="cb36-6" data-line-number="6">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-7" data-line-number="7"><span class="ot">    nat ::</span> <span class="dt">Tr</span> x y <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m x y</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    nat xy <span class="fu">=</span> arr <span class="fu">$</span> natPure xy</a></code></pre></div>
<p>Unpacking the <code>Kleisli</code> category gives us:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">chechoutM&#39; ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ShoppingCat</span> a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">chechoutM&#39; <span class="fu">=</span> runKleisli <span class="fu">.</span> checkoutM</a></code></pre></div>
<p>The freedom of the choice of monad in the Kleisli category can give you various ways of dealing with exceptional conditions (e.g. not valid card) and error handling (<code>IOException</code>s …). Also having various interpretation can be very good for testing, e.g. having a reference implementation might be a very good idea to increase assurance of the software you are developing. Check out Duncan Coutts’ <a
href="https://www.youtube.com/watch?v=mhKUHpQZIoc">lecture</a> on this technique.</p>
<h2 id="finally-tagless-description">Finally tagless description</h2>
<p>We can give a finally tagless description of the shopping category. For that we first define the class of categories in which one can do all the <code>Tr</code> operations:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Category</span> c <span class="ot">=&gt;</span> <span class="dt">ShoppingCatT</span> (<span class="ot">c ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="ot">    selectFirst ::</span> <span class="dt">CartItem</span> <span class="ot">-&gt;</span> c <span class="dt">NoItems</span> <span class="dt">HasItems</span></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="ot">    select      ::</span> <span class="dt">CartItem</span> <span class="ot">-&gt;</span> c <span class="dt">HasItems</span> <span class="dt">HasItems</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"><span class="ot">    selectCard  ::</span> <span class="dt">Card</span> <span class="ot">-&gt;</span> c <span class="dt">HasItems</span> <span class="dt">CardSelected</span></a>
<a class="sourceLine" id="cb38-5" data-line-number="5"><span class="ot">    confirm     ::</span> c <span class="dt">CardSelected</span> <span class="dt">CardConfirmed</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6"><span class="ot">    placeOrder  ::</span> c <span class="dt">CardConfirmed</span> <span class="dt">OrderPlaced</span></a>
<a class="sourceLine" id="cb38-7" data-line-number="7"><span class="ot">    cancel      ::</span> c s <span class="dt">NoItems</span></a>
<a class="sourceLine" id="cb38-8" data-line-number="8"></a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">ShoppingCatT</span> (<span class="dt">Cat</span> <span class="dt">Tr</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-10" data-line-number="10">    selectFirst <span class="fu">=</span> liftCat <span class="fu">.</span> <span class="dt">SelectFirst</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">    select      <span class="fu">=</span> liftCat <span class="fu">.</span> <span class="dt">Select</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12">    selectCard  <span class="fu">=</span> liftCat <span class="fu">.</span> <span class="dt">SelectCard</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13">    confirm     <span class="fu">=</span> liftCat <span class="dt">Confirm</span></a>
<a class="sourceLine" id="cb38-14" data-line-number="14">    placeOrder  <span class="fu">=</span> liftCat <span class="dt">PlaceOrder</span></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">    cancel      <span class="fu">=</span> liftCat <span class="dt">Cancel</span></a></code></pre></div>
<p>There is a unique functor <code>embed :: ShopingCatT c =&gt; ShoppingCat a b -&gt; c a b</code> which with preserves all the operations, e.g.</p>
<pre><code>embed (SelectFirst i) = selectFirst i 
embed (Select i)      = select i
embed (SelectCard v)  = selectCard v
embed Confirm         = confirm
embed PlaceOrder      = placeOrder
embed Cancel          = cancel</code></pre>
<p>This property does not leave any space how this functor has to be implemented, that’s why <code>ShoppingCat</code> is the initial <code>ShoppingCatT</code> category.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="ot">embed ::</span> forall c a b<span class="fu">.</span> <span class="dt">ShoppingCatT</span> c</a>
<a class="sourceLine" id="cb40-2" data-line-number="2">      <span class="ot">=&gt;</span> <span class="dt">ShoppingCat</span> a b</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">      <span class="ot">-&gt;</span> c a b</a>
<a class="sourceLine" id="cb40-4" data-line-number="4">embed <span class="fu">=</span> foldFunCat nat</a>
<a class="sourceLine" id="cb40-5" data-line-number="5">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-6" data-line-number="6"><span class="ot">    nat ::</span> <span class="dt">Tr</span> x y <span class="ot">-&gt;</span> c x y</a>
<a class="sourceLine" id="cb40-7" data-line-number="7">    nat (<span class="dt">SelectFirst</span> i) <span class="fu">=</span> selectFirst i</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">    nat (<span class="dt">Select</span> i)      <span class="fu">=</span> select i</a>
<a class="sourceLine" id="cb40-9" data-line-number="9">    nat (<span class="dt">SelectCard</span> c)  <span class="fu">=</span> selectCard c</a>
<a class="sourceLine" id="cb40-10" data-line-number="10">    nat <span class="dt">Confirm</span>         <span class="fu">=</span> confirm</a>
<a class="sourceLine" id="cb40-11" data-line-number="11">    nat <span class="dt">PlaceOrder</span>      <span class="fu">=</span> placeOrder</a>
<a class="sourceLine" id="cb40-12" data-line-number="12">    nat <span class="dt">Cancel</span>          <span class="fu">=</span> cancel</a></code></pre></div>
<h2 id="complete-graph-with-a-single-vertex">Complete graph with a single vertex</h2>
<p>Let us go back to the <code>Single e v</code> graph.</p>
<p>A graph is <a href="https://en.wikipedia.org/wiki/Complete_graph">complete</a> if every two vertices are connected by a unique edge. It may also happen that all the vertices can be represented by a single type <code>a</code>. Then the whole theory collapses to a category with a single object, i.e. a monoid (as we discovered earlier for the <code>Single e v</code> graph). In this case the generating graph can also be reduced to just a single type (usually a sum of all possible events). In this case one can describe the state machine simply by a free monoid <code>[e]</code> where <code>e</code> represents the type of events and use the following version of <code>foldMapKleisli</code> (<code>foldFunCat</code>) to give interpretations:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="ot">foldMapKleisli ::</span> <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">               <span class="ot">=&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m v v)</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">               <span class="ot">-&gt;</span> [e]</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">               <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m v v</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">foldMapKleisli _ [] <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb41-6" data-line-number="6">foldMapKleisli f (e <span class="fu">:</span> es) <span class="fu">=</span> f e <span class="fu">&lt;&lt;&lt;</span> foldMapKleisli f es</a></code></pre></div>
<p>The first argument of <code>foldMapKleisli</code> maps events to (monadic) state transformations. You can model pure transformations with <code>Kleisli Identity</code> (<code>Kleisli Identity a v ≅ v -&gt; v</code>), or you might want to use <code>IO</code> with <code>Kleisli IO</code> (<code>Kleisli IO v v ≅ v -&gt; IO v</code>).</p>
<p>And again, what you are seeing here is <code>foldMap</code>, this is simply because <code>Kleisli m v v</code> is a monoid (as every type <code>Category c =&gt; cat a a</code> is). The composition is given by <code>&lt;&lt;&lt;</code> and <code>mempty</code> is the identity arrow <code>id</code>, so the above formula corresponds to <code>foldMap</code>. This is the very special case if your state machine can be represented as a single object category, i.e. a monoid.</p>


                
<footer class="post_footer">
    <div class="home">
	<a href="/">Home</a>
    </div>
    <div class="twitter">
	Follow me on twitter <a href="https://twitter.com/me_coot">@me_coot</a>
    </div>
</footer>

	    </main>
	    <div class="clearfix"></div>
	</div>
        <footer>
            Copyright © Marcin Szamotulski 2017-2018, <a href="https://raw.githubusercontent.com/coot/homepage/master/LICENSE"><span class="license">license</span></a>
        </footer>
    </body>
</html>
